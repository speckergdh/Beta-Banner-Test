<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Beta Canvas Banner Creator</title>
  
  <!-- External Libraries -->
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Roboto:wght@300;400;500;700&family=Montserrat:wght@300;400;500;600;700&family=Open+Sans:wght@300;400;600;700&family=Playfair+Display:wght@400;500;600;700&family=Lato:wght@300;400;700&family=Oswald:wght@300;400;500;600;700&family=Raleway:wght@300;400;500;600;700&family=Merriweather:wght@300;400;700&family=Quicksand:wght@300;400;500;600;700&family=Fira+Sans:wght@300;400;500;600;700&family=Nunito:wght@300;400;600;700&family=Inconsolata:wght@400;500;600;700&family=Rubik:wght@300;400;500;600;700&family=PT+Sans:wght@400;700&family=Source+Sans+Pro:wght@300;400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <style>
         /* CSS Variables for Sinclair Brand Colors */
     :root {
       --sinclair-red: #0b325c;
       --sinclair-charcoal: #616366;
       --sinclair-black: #000000;
       --sinclair-royal-blue: #130078;
       --sinclair-green: #1C5840;
       --sinclair-aqua: #01A6F0;
       --sinclair-purple: #850054;
       --sinclair-mint: #007972;
       
       /* UI Colors */
       --primary-color: var(--sinclair-red);
       --secondary-color: var(--sinclair-charcoal);
       --background-color: #0a0a0a;
       --surface-color: rgba(255, 255, 255, 0.95);
       --surface-color-solid: #ffffff;
       --border-color: rgba(255, 255, 255, 0.1);
       --text-primary: #1a1a1a;
       --text-secondary: #666666;
       
       /* Spacing */
       --spacing-xs: 1px;
       --spacing-sm: 2px;
       --spacing-md: 4px;
       --spacing-lg: 6px;
       --spacing-xl: 8px;
       
       /* Border Radius */
       --border-radius-sm: 0px;
       --border-radius-md: 0px;
       --border-radius-lg: 0px;
       
       /* Shadows */
       --shadow-sm: 0 2px 8px rgba(0,0,0,0.1);
       --shadow-md: 0 8px 24px rgba(0,0,0,0.15);
       --shadow-lg: 0 16px 48px rgba(0,0,0,0.2);
       --shadow-glow: 0 0 20px rgba(97, 99, 102, 0.3);
       
       /* Glassmorphism */
       --glass-bg: rgba(255, 255, 255, 0.1);
       --glass-border: rgba(255, 255, 255, 0.2);
       --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
     }

    /* Reset and Base Styles */
    * {
      box-sizing: border-box;
    }

                   body {
        font-family: 'Montserrat', 'Arial', sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
        color: var(--text-primary);
        line-height: 1.6;
        min-height: 100vh;
      }

         /* Layout */
     .container {
       max-width: 1800px;
       margin: 0 auto;
       padding: var(--spacing-xl);
     }

         .header {
       text-align: center;
       margin-bottom: var(--spacing-lg);
       padding: var(--spacing-lg);
       background: var(--surface-color);
       backdrop-filter: blur(20px);
       border: 1px solid var(--glass-border);
       border-radius: var(--border-radius-lg);
       box-shadow: var(--glass-shadow);
       position: relative;
       overflow: hidden;
     }
     
     .header::before {
       content: '';
       position: absolute;
       top: 0;
       left: 0;
       right: 0;
       height: 2px;
       background: linear-gradient(90deg, var(--primary-color), var(--sinclair-aqua));
     }

                   .header h1 {
        color: var(--primary-color);
        margin: 0;
        font-size: 2.5rem;
        font-family: 'Montserrat', 'Arial', sans-serif;
        font-weight: 700;
        letter-spacing: -0.03em;
        position: relative;
        z-index: 1;
        text-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

     .header .version-info {
       color: var(--text-secondary);
       font-size: 0.9rem;
       margin-top: var(--spacing-sm);
       font-style: italic;
     }

    .header p {
      color: var(--text-secondary);
      margin: var(--spacing-sm) 0 0 0;
      font-size: 1.1rem;
    }

    /* Main Content Layout */
    .main-content {
      margin-top: var(--spacing-xl);
    }

                   /* Controls Panel */
             .controls-panel {
         background: var(--surface-color);
         backdrop-filter: blur(20px);
         padding: var(--spacing-md);
         border: 1px solid var(--glass-border);
         border-radius: var(--border-radius-lg);
         box-shadow: var(--glass-shadow);
         margin-bottom: var(--spacing-lg);
         position: relative;
         overflow: hidden;
       }
      
      .controls-panel::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      }

                   /* Controls Grid */
             .controls-grid {
         display: grid;
         grid-template-columns: repeat(4, 1fr);
         gap: var(--spacing-lg);
         max-width: 1600px;
         margin: 0 auto;
       }

                   .controls-panel h2 {
        color: var(--primary-color);
        margin: 0 0 var(--spacing-sm) 0;
        font-size: 1.3rem;
        font-weight: 700;
        letter-spacing: -0.01em;
        position: relative;
        z-index: 1;
      }
      
      .customization-title {
        background: var(--sinclair-red);
        color: white !important;
        font-size: 2rem;
        font-weight: 800;
        text-align: center;
        margin-bottom: calc(var(--spacing-xl) + 40px);
        padding: var(--spacing-md) var(--spacing-lg);
        border-radius: var(--border-radius-sm);
        position: relative;
        box-shadow: var(--shadow-md);
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
      }
      
      /* Collapsible sections */
      .section-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.25rem 0.4rem;
        background: linear-gradient(135deg, var(--primary-color) 0%, #061a2e 100%);
        border: 2px solid var(--primary-color);
        border-bottom: none;
        border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
        cursor: pointer;
        user-select: none;
        transition: all 0.2s ease;
        box-shadow: var(--shadow-sm);
        width: 100%;
        box-sizing: border-box;
      }
      
      .section-header:hover {
        background: linear-gradient(135deg, #061a2e 0%, #040f1a 100%);
        border-color: var(--primary-color-dark);
      }
      
      .section-header h3 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
        color: white;
        background: transparent !important;
        -webkit-background-clip: initial !important;
        -webkit-text-fill-color: white !important;
      }
      
      .section-toggle {
        font-size: 0.8rem;
        transition: transform 0.3s ease;
        color: white;
        font-weight: bold;
      }
      
      .section-toggle.collapsed {
        transform: rotate(-90deg);
      }
      
      .section-content {
        padding: 0.15rem;
        border: 2px solid var(--primary-color);
        border-top: none;
        border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);
        background: transparent;
        transition: all 0.3s ease;
        overflow: hidden;
        box-shadow: none;
      }
      
      .section-content.collapsed {
        max-height: 0;
        padding: 0;
        border: none;
        box-shadow: none;
        margin: 0;
      }
      
      /* Control section improvements */
      .control-section {
        margin-bottom: 0.25rem;
        border-radius: var(--border-radius-md);
        overflow: hidden;
        box-shadow: var(--shadow-sm);
      }
      
      .control-section.collapsed {
        margin-bottom: 0.1rem;
      }
      
      /* Tighten overall spacing */
      .controls-grid {
        gap: 0.15rem;
      }
      
      .controls-panel {
        padding: 0.5rem;
      }
      
      .customization-title {
        margin-bottom: 0.25rem;
        font-size: 1rem;
      }
      
      /* Additional spacing and border fixes */
      .controls-panel h2 {
        margin-bottom: 0.15rem;
      }
      
      .main-content {
        gap: 0.3rem;
      }
      
      .preview-panel {
        padding: 0.5rem;
      }
      
      .preview-panel h2 {
        margin-bottom: 0.15rem;
      }
      
      /* Ensure all inputs have borders */
      input[type="range"] {
        border: none !important;
        background: transparent !important;
        box-shadow: none !important;
      }
      
      input[type="color"] {
        border: 2px solid var(--border-color) !important;
        border-radius: var(--border-radius-sm) !important;
        padding: 0.25rem !important;
        height: 40px !important;
        width: 100% !important;
      }
      
      /* Logo controls spacing */
      .logo-controls {
        display: flex;
        align-items: center;
        gap: 0.15rem;
        margin-top: 0.1rem;
      }
      
      .logo-controls label {
        margin: 0;
        font-size: 0.8rem;
        font-weight: 500;
      }
      
      .logo-controls input[type="range"] {
        flex: 1;
      }
      
      .logo-controls span {
        font-size: 0.8rem;
        font-weight: 600;
        min-width: 50px;
        text-align: right;
      }
      
      /* Reset position button styling */
      #resetBgImagePosition {
        background: var(--primary-color) !important;
        color: white !important;
        border: 2px solid var(--primary-color) !important;
        border-radius: var(--border-radius-sm) !important;
        padding: 0.5rem 1rem !important;
        font-weight: 600 !important;
        font-size: 0.8rem !important;
        cursor: pointer !important;
        transition: all 0.2s ease !important;
        box-shadow: var(--shadow-sm) !important;
        text-transform: uppercase !important;
        letter-spacing: 0.5px !important;
        min-height: 36px !important;
        display: inline-flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
      
      #resetBgImagePosition:hover {
        background: var(--primary-color-dark) !important;
        border-color: var(--primary-color-dark) !important;
        transform: translateY(-1px) !important;
        box-shadow: var(--shadow-md) !important;
      }
      
      #resetBgImagePosition:active {
        transform: translateY(0) !important;
        box-shadow: var(--shadow-sm) !important;
      }
      
      /* Form group borders for better readability */
      .form-group {
        margin-bottom: 0.15rem;
        padding: 0.35rem;
        border: none;
        border-radius: var(--border-radius-sm);
        background: transparent;
        box-shadow: none;
      }
      
      .form-group:last-child {
        margin-bottom: 0;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 0.1rem;
        font-weight: 600;
        color: var(--text-primary);
        font-size: 0.75rem;
      }
      
      .form-group input,
      .form-group select,
      .form-group textarea {
        width: 100%;
        padding: 0.4rem;
        border: 2px solid;
        border-image: linear-gradient(135deg, var(--primary-color) 0%, #061a2e 100%) 1;
        border-radius: var(--border-radius-sm);
        font-size: 13px;
        transition: all 0.3s ease;
        background-color: var(--surface-color-solid);
        color: var(--text-primary);
        backdrop-filter: blur(10px);
        box-sizing: border-box;
        min-height: 32px;
        box-shadow: var(--shadow-glow);
      }
      
      .form-group input:focus,
      .form-group select:focus,
      .form-group textarea:focus {
        outline: none;
        border-image: linear-gradient(135deg, var(--primary-color) 0%, #040f1a 100%) 1;
        box-shadow: var(--shadow-glow);
        transform: translateY(-1px);
      }
      
      /* Make dropdown triangles smaller */
      .form-group select {
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 6px center;
        background-size: 8px;
        padding-right: 25px;
      }
      
      /* Ensure only form inputs have gradient borders */
      .form-group input[type="text"],
      .form-group input[type="number"],
      .form-group input[type="email"],
      .form-group input[type="password"],
      .form-group input[type="url"],
      .form-group input[type="tel"],
      .form-group input[type="search"],
      .form-group input[type="file"],
      .form-group select,
      .form-group textarea {
        border: 2px solid !important;
        border-image: linear-gradient(135deg, var(--primary-color) 0%, #061a2e 100%) 1 !important;
        border-radius: var(--border-radius-sm) !important;
        padding: 0.5rem !important;
        background-color: var(--surface-color-solid) !important;
        color: var(--text-primary) !important;
        font-size: 14px !important;
        transition: all 0.3s ease !important;
        box-sizing: border-box !important;
        box-shadow: var(--shadow-glow) !important;
      }
      
      .form-group input[type="text"]:focus,
      .form-group input[type="number"]:focus,
      .form-group input[type="email"]:focus,
      .form-group input[type="password"]:focus,
      .form-group input[type="url"]:focus,
      .form-group input[type="tel"]:focus,
      .form-group input[type="search"]:focus,
      .form-group input[type="file"]:focus,
      .form-group select:focus,
      .form-group textarea:focus {
        outline: none !important;
        border-image: linear-gradient(135deg, var(--primary-color) 0%, #040f1a 100%) 1 !important;
        box-shadow: var(--shadow-glow) !important;
        transform: translateY(-1px) !important;
      }

                   /* Form Groups - Override for specific cases */
      .form-group.legacy {
        margin-bottom: var(--spacing-sm);
        padding: 0;
        border: none;
        background: none;
        box-shadow: none;
      }

    .form-group.legacy label {
      display: block;
      margin-bottom: var(--spacing-xs);
      font-weight: 500;
      color: var(--text-primary);
    }

         .form-group.legacy input,
     .form-group.legacy select {
       width: 100%;
       padding: var(--spacing-xs);
       border: 2px solid var(--border-color);
       border-radius: var(--border-radius-sm);
       font-size: 14px;
       transition: all 0.3s ease;
       background-color: var(--surface-color-solid);
       color: var(--text-primary);
       backdrop-filter: blur(10px);
     }

    .form-group select option {
      background-color: white;
      color: var(--text-primary);
      padding: 8px;
      font-size: 16px;
      line-height: 1.5;
    }

         .form-group input:focus,
     .form-group select:focus {
       outline: none;
       border-color: var(--primary-color);
       box-shadow: var(--shadow-glow);
       transform: translateY(-1px);
     }

    .form-group input[type="color"] {
      height: 50px;
      padding: var(--spacing-sm);
    }
    
    .color-picker-group {
      display: flex;
      gap: var(--spacing-xs);
      align-items: flex-end;
      flex-wrap: wrap;
      padding: 0;
      border: none;
      background: none;
      box-shadow: none;
    }
    
    .color-picker-group .form-group {
      flex: 1;
      min-width: 80px;
      margin-bottom: 0;
    }
    
    .color-picker {
      height: 30px;
      width: 100%;
      padding: 2px;
      border: 2px solid var(--border-color);
      border-radius: var(--border-radius-sm);
      cursor: pointer;
    }
    
    .dimension-buttons {
      display: flex;
      gap: var(--spacing-xs);
      margin-top: var(--spacing-sm);
      padding: 0;
      border: none;
      background: none;
      box-shadow: none;
    }
    
    .dimension-buttons .btn {
      flex: 1;
      padding: var(--spacing-sm) var(--spacing-md);
      font-size: 13px;
      font-weight: 600;
      text-align: center;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      background: var(--surface-color-solid);
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
    }
    
    .dimension-buttons .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .dimension-buttons .btn:hover {
      background: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    .dimension-buttons .btn:hover::before {
      left: 100%;
    }
    
    .dimension-buttons .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }

    .form-group input[type="file"] {
      padding: var(--spacing-sm);
    }

    .form-group input[type="range"] {
      width: 70%;
      margin-right: var(--spacing-sm);
    }

    .form-group span {
      font-weight: 500;
      color: var(--text-secondary);
    }

                             /* Control Sections */
      .control-section {
        margin-bottom: var(--spacing-md);
        padding: var(--spacing-sm);
        border: 2px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        position: relative;
        overflow: hidden;
      }
      
      /* Color-coded section backgrounds and borders - alternating gray and gray */
      .control-section:nth-child(odd) {
        background: rgba(97, 99, 102, 0.15);
        border-color: var(--sinclair-charcoal);
        border-left: 4px solid var(--sinclair-charcoal);
      }
      
      .control-section:nth-child(even) {
        background: rgba(97, 99, 102, 0.15);
        border-color: var(--sinclair-charcoal);
        border-left: 4px solid var(--sinclair-charcoal);
      }
       
       /* Hover effects for sections */
       .control-section:nth-child(odd):hover {
         background: rgba(97, 99, 102, 0.25);
         transform: translateY(-1px);
         box-shadow: var(--shadow-sm);
         transition: all 0.3s ease;
       }
       
       .control-section:nth-child(even):hover {
         background: rgba(97, 99, 102, 0.25);
         transform: translateY(-1px);
         box-shadow: var(--shadow-sm);
         transition: all 0.3s ease;
       }
       
       /* Section header backgrounds matching border colors - alternating gray and gray */
       .control-section:nth-child(odd) h3 {
         background: var(--sinclair-charcoal);
         color: white;
         margin: 0 0 var(--spacing-sm) 0;
         font-size: 1.1rem;
         font-weight: 700;
         padding: var(--spacing-sm) var(--spacing-md);
         border-radius: var(--border-radius-sm);
         position: relative;
         box-shadow: var(--shadow-sm);
       }
       
       .control-section:nth-child(even) h3 {
         background: var(--sinclair-charcoal);
         color: white;
         margin: 0 0 var(--spacing-sm) 0;
         font-size: 1.1rem;
         font-weight: 700;
         padding: var(--spacing-sm) var(--spacing-md);
         border-radius: var(--border-radius-sm);
         position: relative;
         box-shadow: var(--shadow-sm);
       }
       

       
       /* All sections equal size */
       .control-section {
         grid-column: span 1;
       }
       
       /* Export buttons styling */
       .export-buttons {
         display: flex;
         flex-wrap: wrap;
         gap: var(--spacing-xs);
         margin-top: var(--spacing-sm);
         margin-bottom: var(--spacing-sm);
         max-height: 200px;
         overflow-y: auto;
         padding: var(--spacing-xs);
         border-radius: var(--border-radius-sm);
         background: transparent;
         position: relative;
         z-index: 1;
         border: none;
         box-shadow: none;
       }
       
       .export-buttons .btn {
         flex: 1;
         min-width: 100px;
         max-width: 150px;
         padding: var(--spacing-xs) var(--spacing-sm);
         border: 2px solid var(--border-color);
         border-radius: 6px;
         background: var(--surface-color-solid);
         color: var(--text-color);
         font-weight: 600;
         text-align: center;
         cursor: pointer;
         transition: all 0.2s ease;
         box-shadow: var(--shadow-sm);
         font-size: 12px;
       }
       
       .export-buttons .btn:hover {
         transform: translateY(-2px);
         box-shadow: var(--shadow-md);
         border-color: var(--primary-color);
       }
       
       .export-buttons .btn-primary {
         background: var(--primary-color);
         color: white;
         border-color: var(--primary-color);
       }
       
       .export-buttons .btn-primary:hover {
         background: var(--primary-color-dark);
         box-shadow: var(--shadow-lg);
       }
       
       .export-buttons .btn-secondary {
         background: var(--surface-color-solid);
         color: var(--text-color);
         border-color: var(--border-color);
       }
       
       .export-buttons .btn-secondary:hover {
         background: var(--surface-color);
         border-color: var(--primary-color);
       }
       
       /* Rounded corners for customization boxes only */
       .control-section {
         border-radius: 8px;
       }
       
       /* Clear and Remove button styling */
       .btn-clear, .btn-remove {
         padding: var(--spacing-sm) var(--spacing-md);
         border: 2px solid var(--border-color);
         border-radius: 6px;
         background: var(--surface-color-solid);
         color: var(--text-color);
         font-weight: 600;
         text-align: center;
         cursor: pointer;
         transition: all 0.2s ease;
         box-shadow: var(--shadow-sm);
         margin-top: var(--spacing-xs);
         width: 100%;
       }
       
       .btn-clear:hover, .btn-remove:hover {
         transform: translateY(-2px);
         box-shadow: var(--shadow-md);
         border-color: var(--primary-color);
       }
       
       .btn-clear {
         background: var(--surface-color-solid);
         color: var(--text-color);
         border-color: var(--border-color);
       }
       
       .btn-clear:hover {
         background: var(--surface-color);
         border-color: var(--primary-color);
       }
       
       .btn-remove {
         background: var(--primary-color);
         color: white;
         border-color: var(--primary-color);
       }
       
       .btn-remove:hover {
         background: #061a2e;
         box-shadow: var(--shadow-lg);
       }

    .control-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

                   .control-section h3 {
        color: var(--primary-color);
        margin: 0 0 var(--spacing-xs) 0;
        font-size: 1rem;
        font-weight: 700;
        padding: var(--spacing-xs) var(--spacing-sm);
        border-bottom: 2px solid var(--primary-color);
        position: relative;
        background: rgba(97, 99, 102, 0.05);
        margin: calc(-1 * var(--spacing-sm)) calc(-1 * var(--spacing-sm)) var(--spacing-xs) calc(-1 * var(--spacing-sm));
      }
     


         /* Button Styles */
     .btn {
       display: inline-block;
       padding: var(--spacing-xs) var(--spacing-sm);
       font-size: 14px;
       font-weight: 600;
       text-align: center;
       text-decoration: none;
       border: none;
       border-radius: var(--border-radius-sm);
       cursor: pointer;
       transition: all 0.3s ease;
       margin-right: var(--spacing-xs);
       margin-bottom: var(--spacing-xs);
       position: relative;
       overflow: hidden;
     }
     
     .btn::before {
       content: '';
       position: absolute;
       top: 0;
       left: -100%;
       width: 100%;
       height: 100%;
       background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
       transition: left 0.5s ease;
     }
     
     .btn:hover::before {
       left: 100%;
     }

    .btn-primary {
      background-color: var(--primary-color);
      color: white;
    }

         .btn-primary:hover {
       background-color: #8b1526;
       transform: translateY(-2px);
       box-shadow: var(--shadow-lg), var(--shadow-glow);
     }

    .btn-secondary {
      background-color: var(--secondary-color);
      color: white;
    }

         .btn-secondary:hover {
       background-color: #4a4d4f;
       transform: translateY(-2px);
       box-shadow: var(--shadow-lg);
     }

    .btn-danger {
      background-color: #dc3545;
      color: white;
    }

         .btn-danger:hover {
       background-color: #c82333;
       transform: translateY(-2px);
       box-shadow: var(--shadow-lg);
     }

    /* Export Buttons */
    .export-buttons {
      margin-top: var(--spacing-xl);
      padding-top: var(--spacing-xl);
      border-top: 2px solid var(--border-color);
    }

    .export-buttons h3 {
      margin: 0 0 var(--spacing-md) 0;
      color: var(--text-primary);
      font-size: 1.2rem;
    }

                   /* Preview Panel */
                   .preview-panel {
        background: var(--surface-color);
        backdrop-filter: blur(20px);
        padding: var(--spacing-lg);
        border: 1px solid var(--glass-border);
        border-radius: var(--border-radius-lg);
        box-shadow: var(--glass-shadow);
        text-align: center;
        overflow: hidden;
        position: sticky;
        top: 20px;
        z-index: 100;
        margin-bottom: var(--spacing-xl);
      }
      
      .preview-wrapper {
        overflow: hidden;
        border-radius: var(--border-radius-md);
        margin: 0 auto;
        max-width: 100%;
      }
      
      .preview-panel::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      }

                   .preview-panel h2 {
        color: var(--primary-color);
        margin: 0 0 var(--spacing-md) 0;
        font-size: 1.5rem;
        font-weight: 700;
        letter-spacing: -0.01em;
        position: relative;
        z-index: 1;
      }

                   /* Banner Preview */
             #bannerPreview {
         position: relative;
         width: 100%;
         max-width: 100%;
         height: 200px;
         display: flex;
         align-items: center;
         justify-content: space-between;
         overflow: visible;
         background-color: var(--sinclair-red);
         padding: var(--spacing-md);
         border-radius: var(--border-radius-md);
         box-shadow: var(--shadow-lg), var(--shadow-glow);
         color: white;
         transition: all 0.3s ease;
         margin: 0 auto;
         border: 1px solid rgba(255, 255, 255, 0.1);
       }

    #bgImage {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
      opacity: 1;
      transition: opacity 0.3s ease;
      transform-origin: center center;
      overflow: hidden;
      cursor: crosshair;
    }
    
    /* Visual crop interface */
    .crop-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      z-index: 1;
      cursor: crosshair;
      display: none;
    }
    
    .crop-window {
      position: absolute;
      border: 2px solid #fff;
      background: transparent;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
      pointer-events: none;
    }
    

    
    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      padding: 8px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    
    .zoom-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
    }
    
    .zoom-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    .zoom-level {
      color: white;
      font-size: 12px;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      min-width: 40px;
      text-align: center;
    }
    
    #bgImage:active {
      cursor: grabbing;
    }
    
    /* Interactive background positioning */
    .preview-wrapper {
      position: relative;
      overflow: hidden;
    }
    
    .bg-image-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: grab;
    }
    
    .bg-image-container:active {
      cursor: grabbing;
    }

    #bannerTextContainer {
      position: relative;
      z-index: 2;
      flex: 1;
      padding-right: var(--spacing-md);
      min-width: 0;
      overflow: visible;
      word-wrap: break-word;
      hyphens: auto;
    }

         #bannerTitle, #bannerSubtitle2, #bannerSubtitle3 {
       margin: 0;
       line-height: 1.2;
       transition: all 0.3s ease;
       word-wrap: break-word;
       overflow-wrap: break-word;
       overflow: visible;
       text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
       font-smooth: antialiased;
       -webkit-font-smoothing: antialiased;
       -moz-osx-font-smoothing: grayscale;
     }

    #bannerTitle {
      font-weight: 700;
      margin-bottom: var(--spacing-xs);
    }

    

    #bannerSubtitle2, #bannerSubtitle3 {
      font-weight: 300;
      opacity: 1;
    }

    #logoImage {
      max-height: 100%;
      max-width: 200px;
      object-fit: contain;
      z-index: 3;
      position: relative;
      margin-left: var(--spacing-sm);
      transition: all 0.3s ease;
      flex-shrink: 0;
      width: auto;
      height: auto;
    }
    
    #shapeElement {
      position: absolute;
      z-index: 1;
      transition: all 0.3s ease;
    }
    
    #shapeElement.block-left {
      left: 0;
      top: 0;
      width: 20px;
      height: 100%;
    }
    
    #shapeElement.block-right {
      right: 0;
      top: 0;
      width: 20px;
      height: 100%;
    }
    
    #shapeElement.block-top {
      top: 0;
      left: 0;
      width: 100%;
      height: 20px;
    }
    
    #shapeElement.block-bottom {
      bottom: 0;
      left: 0;
      width: 100%;
      height: 20px;
    }
    
    #shapeElement.block-wide-left {
      left: 0;
      top: 0;
      width: 60px;
      height: 100%;
    }
    
    #shapeElement.block-wide-right {
      right: 0;
      top: 0;
      width: 60px;
      height: 100%;
    }
    
    #shapeElement.block-wide-top {
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
    }
    
    #shapeElement.block-wide-bottom {
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
    }
    
    /* Unsplash Integration Styles */
    .unsplash-search {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .unsplash-search input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    
    .unsplash-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 10px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px;
      background: #f9f9f9;
    }
    
    .unsplash-image {
      width: 100%;
      height: 80px;
      object-fit: cover;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s ease;
      border: 2px solid transparent;
    }
    
    .unsplash-image:hover {
      transform: scale(1.05);
      border-color: #007bff;
    }
    
    .unsplash-image.selected {
      border-color: #28a745;
    }
    
    #unsplashLoading {
      text-align: center;
      padding: 20px;
      color: #666;
    }
    
    #shapeElement.block-corner-tl {
      top: 0;
      left: 0;
      width: 60px;
      height: 60px;
    }
    
    #shapeElement.block-corner-tr {
      top: 0;
      right: 0;
      width: 60px;
      height: 60px;
    }
    
    #shapeElement.block-corner-bl {
      bottom: 0;
      left: 0;
      width: 60px;
      height: 60px;
    }
    
    #shapeElement.block-corner-br {
      bottom: 0;
      right: 0;
      width: 60px;
      height: 60px;
    }
    
    #shapeElement.block-center {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
    }
    
    #shapeElement.block-diagonal {
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: rotate(45deg);
      transform-origin: center;
    }
    
    #shapeElement.block-circle {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      border-radius: 50%;
    }
    
    #shapeElement.block-oval {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 120px;
      height: 60px;
      border-radius: 50%;
    }
    
    #shapeElement.block-center-left {
      top: 50%;
      left: 20px;
      transform: translateY(-50%);
      width: 100px;
      height: 100px;
    }
    
    #shapeElement.block-center-right {
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      width: 100px;
      height: 100px;
    }
    
    #shapeElement.block-center-top {
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 100px;
    }
    
    #shapeElement.block-center-bottom {
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 100px;
    }
    
    #shapeElement.block-triangle {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 86px solid;
      background: none;
    }
    
    #shapeElement.block-diamond {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: 80px;
      height: 80px;
    }
    
    #shapeElement.block-hexagon {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    }
    
    .logo-controls {
      display: flex;
      gap: var(--spacing-xs);
      align-items: center;
      margin-top: var(--spacing-xs);
    }
    
    .logo-controls label {
      font-size: 12px;
      margin: 0;
      min-width: 60px;
    }
    
    .logo-controls input[type="range"] {
      flex: 1;
      margin: 0;
    }
    
    .logo-controls span {
      font-size: 12px;
      min-width: 40px;
      text-align: right;
    }
    
    .position-controls {
      display: flex;
      gap: var(--spacing-xs);
      justify-content: center;
      margin-top: var(--spacing-xs);
    }
    
    .position-controls button {
      width: 40px;
      height: 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 4px;
    }

         /* Responsive Design */
     @media (max-width: 1400px) {
       .controls-grid {
         grid-template-columns: repeat(3, 1fr);
       }
     }
     
     @media (max-width: 1200px) {
       .controls-grid {
         grid-template-columns: repeat(2, 1fr);
       }
     }
     
     @media (max-width: 768px) {
       .controls-grid {
         grid-template-columns: 1fr;
       }
       
       .container {
         padding: var(--spacing-md);
       }
       
       .header h1 {
         font-size: 2rem;
       }
       
       #bannerPreview {
         height: 150px;
         padding: var(--spacing-md);
         max-width: 100%;
       }
       
       #logoImage {
         max-width: 80px;
       }
       
       .preview-panel {
         padding: var(--spacing-md);
         position: sticky;
         top: 20px;
         z-index: 100;
       }
     }

    /* Loading States */
    .loading {
      opacity: 0.7;
      pointer-events: none;
    }

    /* Success/Error Messages */
    #messageContainer {
      padding: 2rem 0;
      margin-top: 1rem;
    }
    
    .message {
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--border-radius-sm);
      margin: var(--spacing-sm) 0;
      font-weight: 500;
    }

    .message.success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .message.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    /* Color Preview */
    .color-preview {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-right: var(--spacing-sm);
      border: 2px solid var(--border-color);
    }

    /* Template Presets */
         .template-presets {
       display: grid;
       grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
       gap: var(--spacing-xs);
       margin-bottom: var(--spacing-sm);
       padding: 0;
       border: none;
       background: none;
       box-shadow: none;
     }

                   .template-preset {
        padding: var(--spacing-xs);
        border: 2px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
        background: var(--surface-color-solid);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }
     
     .template-preset::before {
       content: '';
       position: absolute;
       top: 0;
       left: 0;
       right: 0;
       bottom: 0;
       background: linear-gradient(135deg, rgba(97, 99, 102, 0.05), rgba(1, 166, 240, 0.05));
       opacity: 0;
       transition: opacity 0.3s ease;
     }

         .template-preset:hover {
       border-color: var(--primary-color);
       background-color: var(--surface-color-solid);
       transform: translateY(-2px);
       box-shadow: var(--shadow-md);
     }
     
     .template-preset:hover::before {
       opacity: 1;
     }

    .template-preset.selected {
      border-color: var(--primary-color);
      background-color: var(--primary-color);
      color: white;
    }

    .template-preview {
      width: 100%;
      height: 40px;
      margin-bottom: var(--spacing-xs);
      border-radius: var(--border-radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }

    /* Emoji Suggestions */
    .emoji-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .emoji-option {
      font-size: 24px;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s ease;
      user-select: none;
    }

    .emoji-option:hover {
      background: var(--primary-color);
      transform: scale(1.1);
    }

    /* New Features Popup */
    .popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }

    .popup-content {
      background: var(--surface-color-solid);
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-xl);
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      border: 2px solid var(--primary-color);
      position: relative;
    }

    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-lg);
      border-bottom: 1px solid var(--border-color);
      background: linear-gradient(135deg, var(--primary-color), #061a2e);
      color: white;
      border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
    }

    .popup-header h2 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 700;
    }

    .popup-close {
      background: none;
      border: none;
      color: white;
      font-size: 2rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    .popup-close:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .popup-body {
      padding: var(--spacing-lg);
    }

    .feature-item {
      display: flex;
      align-items: flex-start;
      margin-bottom: var(--spacing-md);
      padding: var(--spacing-sm);
      border-radius: var(--border-radius-sm);
      background: rgba(11, 50, 92, 0.05);
      border-left: 4px solid var(--primary-color);
    }

    .feature-icon {
      font-size: 2rem;
      margin-right: var(--spacing-md);
      flex-shrink: 0;
    }

    .feature-text h3 {
      margin: 0 0 var(--spacing-xs) 0;
      color: var(--primary-color);
      font-size: 1.1rem;
      font-weight: 600;
    }

    .feature-text p {
      margin: 0;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .feature-demo {
      margin-top: var(--spacing-lg);
      padding: var(--spacing-md);
      background: rgba(11, 50, 92, 0.1);
      border-radius: var(--border-radius-sm);
      border: 1px solid var(--border-color);
    }

    .feature-demo p {
      margin: 0 0 var(--spacing-sm) 0;
      font-weight: 600;
      color: var(--primary-color);
    }

    .feature-demo ol {
      margin: 0;
      padding-left: var(--spacing-md);
      color: var(--text-secondary);
    }

    .feature-demo li {
      margin-bottom: var(--spacing-xs);
      line-height: 1.4;
    }

    .popup-footer {
      padding: var(--spacing-lg);
      border-top: 1px solid var(--border-color);
      text-align: center;
    }

    .popup-footer .btn {
      min-width: 120px;
    }
  </style>
</head>
<body>
  <div class="container">
         <!-- Header -->
     <div class="header">
               <h1>Canvas Banner Creator</h1>
        <div class="version-info">Built on August 3, 2025 - Version 3.0 - Hampton</div>
     </div>
     
     <!-- New Features Popup -->
     <div id="newFeaturesPopup" class="popup-overlay">
       <div class="popup-content">
         <div class="popup-header">
           <h2>🎉 New Features Available!</h2>
           <button class="popup-close" onclick="closeNewFeaturesPopup()">×</button>
         </div>
         <div class="popup-body">
           <div class="feature-item">
             <div class="feature-icon">🎨</div>
             <div class="feature-text">
               <h3>Icon/Emoji Selector</h3>
               <p>Add icons and emojis to your banners! Perfect for Canvas LMS since it doesn't support external images.</p>
             </div>
           </div>
           <div class="feature-item">
             <div class="feature-icon">📄</div>
             <div class="feature-text">
               <h3>HTML Export</h3>
               <p>Export banners as HTML for direct use in Canvas LMS. No external dependencies required!</p>
             </div>
           </div>
           <div class="feature-item">
             <div class="feature-icon">🎯</div>
             <div class="feature-text">
               <h3>Canvas-Compatible</h3>
               <p>All exports are optimized for Canvas LMS with inline styles and accessible content.</p>
             </div>
           </div>
           <div class="feature-demo">
             <p><strong>Try it now:</strong></p>
             <ol>
               <li>Go to the "Logo Upload" section</li>
               <li>Change "Logo Type" to "Icon/Emoji"</li>
               <li>Choose an emoji or type your own</li>
               <li>Pick a color for your icon</li>
               <li>Export as HTML for Canvas!</li>
             </ol>
           </div>
         </div>
         <div class="popup-footer">
           <button class="btn btn-primary" onclick="closeNewFeaturesPopup()">Got it!</button>
         </div>
       </div>
     </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Preview Panel -->
      <div class="preview-panel">
        <h2>Live Preview</h2>
        <div class="preview-wrapper">
                 <div id="bannerPreview">
           <img id="bgImage" alt="Background" style="display: none;" />
           <div id="shapeElement" style="display: none;"></div>
           <div id="bannerTextContainer">
             <h2 id="bannerTitle"></h2>
             <p id="bannerSubtitle2"></p>
             <p id="bannerSubtitle3"></p>
           </div>
           <img id="logoImage" alt="Logo" style="display: none;" />
        <div id="logoIcon" style="display: none; font-size: 120px; color: #ffffff; position: absolute; right: 20px; top: 50%; transform: translateY(-50%);"></div>
           <div class="crop-overlay" id="cropOverlay">
             <div class="crop-window" id="cropWindow"></div>
           </div>

         </div>
        </div>
        <div id="messageContainer"></div>
      </div>

      <!-- Controls Panel -->
      <div class="controls-panel">
        <h2 class="customization-title">Customization Options</h2>
        
        <div class="controls-grid">
          <!-- Template Presets Section -->
          <div class="control-section">
            <div class="section-header" onclick="toggleSection('templatesSection')">
              <h3>Quick Templates</h3>
              <span class="section-toggle" id="templatesToggle">▼</span>
            </div>
            <div class="section-content" id="templatesSection">
            <div class="template-presets">
              <div class="template-preset" onclick="applyTemplate('academic')">
                <div class="template-preview" style="background: linear-gradient(135deg, #AC1A2F, #8b1526);">Academic</div>
                <div>Academic Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('business')">
                <div class="template-preview" style="background: linear-gradient(135deg, #616366, #4a4d4f);">Business</div>
                <div>Business Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('science')">
                <div class="template-preview" style="background: linear-gradient(135deg, #1C5840, #0f3a2a);">Science</div>
                <div>Science Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('arts')">
                <div class="template-preview" style="background: linear-gradient(135deg, #850054, #6a0043);">Arts</div>
                <div>Arts Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('technology')">
                <div class="template-preview" style="background: linear-gradient(135deg, #01A6F0, #0077B5);">Technology</div>
                <div>Technology Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('healthcare')">
                <div class="template-preview" style="background: linear-gradient(135deg, #00B894, #00A085);">Healthcare</div>
                <div>Healthcare Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('education')">
                <div class="template-preview" style="background: linear-gradient(135deg, #6C5CE7, #5B4BC4);">Education</div>
                <div>Education Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('engineering')">
                <div class="template-preview" style="background: linear-gradient(135deg, #FDCB6E, #E17055);">Engineering</div>
                <div>Engineering Course</div>
              </div>
              <div class="template-preset" onclick="applyTemplate('humanities')">
                <div class="template-preview" style="background: linear-gradient(135deg, #A29BFE, #8B7EC8);">Humanities</div>
                <div>Humanities Course</div>
              </div>
            </div>
            </div>
          </div>

                     <!-- Text Content Section -->
           <div class="control-section">
             <div class="section-header" onclick="toggleSection('textContentSection')">
               <h3>Text Content</h3>
               <span class="section-toggle" id="textContentToggle">▼</span>
             </div>
             <div class="section-content" id="textContentSection">
             <div class="form-group">
               <label for="title">Course Title</label>
               <input type="text" id="title" value="" placeholder="Enter course title">
             </div>
             
             <div class="form-group">
               <label for="subtitle2">Optional Subtitle</label>
               <input type="text" id="subtitle2" placeholder="Enter additional subtitle (optional)">
             </div>
             
             <div class="form-group">
               <label for="subtitle3">Second Subtitle</label>
               <input type="text" id="subtitle3" placeholder="Enter second subtitle (optional)">
             </div>
             
             <div class="color-picker-group">
               <div class="form-group">
                 <label for="titleColor">Title Color</label>
                 <input type="color" id="titleColor" value="#ffffff" class="color-picker">
               </div>
               
               <div class="form-group">
                 <label for="subtitleColor">Subtitle Color</label>
                 <input type="color" id="subtitleColor" value="#ffffff" class="color-picker">
               </div>
               
               <div class="form-group">
                 <label for="subtitle3Color">Subtitle 2 Color</label>
                 <input type="color" id="subtitle3Color" value="#ffffff" class="color-picker">
               </div>
             </div>
             </div>
           </div>

                                <!-- Typography Section -->
            <div class="control-section typography-section">
             <div class="section-header" onclick="toggleSection('typographySection')">
               <h3>Typography</h3>
               <span class="section-toggle" id="typographyToggle">▼</span>
             </div>
             <div class="section-content" id="typographySection">
             <div class="form-group">
               <label for="titleSize">Title Size (px)</label>
               <input type="number" id="titleSize" value="32" min="16" max="72">
             </div>
             
             <div class="form-group">
               <label for="subtitleSize">Subtitle Size (px)</label>
               <input type="number" id="subtitleSize" value="18" min="12" max="48">
             </div>
             
             <div class="form-group">
               <label for="fontChoice">Font Family</label>
               <select id="fontChoice">
                 <option value="Roboto">Roboto</option>
                 <option value="Montserrat">Montserrat</option>
                 <option value="Open Sans">Open Sans</option>
                 <option value="Playfair Display">Playfair Display</option>
                 <option value="Lato">Lato</option>
                 <option value="Oswald">Oswald</option>
                 <option value="Raleway">Raleway</option>
                 <option value="Merriweather">Merriweather</option>
                 <option value="Quicksand">Quicksand</option>
                 <option value="Fira Sans">Fira Sans</option>
                 <option value="Nunito">Nunito</option>
                 <option value="Inconsolata">Inconsolata</option>
                 <option value="Rubik">Rubik</option>
                 <option value="PT Sans">PT Sans</option>
                 <option value="Source Sans Pro">Source Sans Pro</option>
               </select>
             </div>
             
             <div class="form-group">
               <label for="textAlign">Text Alignment</label>
               <select id="textAlign">
                 <option value="left">Left</option>
                 <option value="center">Center</option>
                 <option value="right">Right</option>
               </select>
             </div>
             </div>
           </div>

                     <!-- Banner Dimensions Section -->
           <div class="control-section banner-dimensions-section">
            <div class="section-header" onclick="toggleSection('dimensionsSection')">
              <h3>Banner Dimensions</h3>
              <span class="section-toggle" id="dimensionsToggle">▼</span>
            </div>
            <div class="section-content" id="dimensionsSection">
            <div class="form-group">
              <label for="bannerWidth">Width (px)</label>
              <input type="number" id="bannerWidth" value="1200" min="400" max="2000">
            </div>
            
            <div class="form-group">
              <label for="bannerHeight">Height (px)</label>
              <input type="number" id="bannerHeight" value="200" min="80" max="400">
            </div>

            <div class="form-group">
              <label for="previewScale">Preview Scale (%)</label>
              <input type="range" id="previewScale" value="100" min="25" max="100" step="25">
              <span id="scaleValue">100%</span>
            </div>
            
            <div class="dimension-buttons">
              <button class="btn btn-secondary" onclick="setCanvasCourseCard()">Canvas Course Card</button>
              <button class="btn btn-secondary" onclick="setCanvasBanner()">Canvas Banner</button>
            </div>
            </div>
          </div>

          <!-- Colors Section -->
          <div class="control-section">
            <div class="section-header" onclick="toggleSection('colorsSection')">
              <h3>Colors</h3>
              <span class="section-toggle" id="colorsToggle">▼</span>
            </div>
            <div class="section-content" id="colorsSection">
                         <div class="form-group">
               <label for="sinclairColor">Sinclair Brand Colors</label>
               <select id="sinclairColor">
                 <option value="">Custom Color</option>
                 <option value="--sinclair-red">Sinclair Red</option>
                 <option value="--sinclair-charcoal">Sinclair Charcoal</option>
                 <option value="--sinclair-black">Sinclair Black</option>
                 <option value="--sinclair-royal-blue">Royal Blue</option>
                 <option value="--sinclair-green">Sinclair Green</option>
                 <option value="--sinclair-aqua">Sinclair Aqua</option>
                 <option value="--sinclair-purple">Sinclair Purple</option>
                 <option value="--sinclair-mint">Sinclair Mint</option>
                 <option value="transparent">No Color</option>
               </select>
             </div>
             
             <div class="form-group">
               <button class="btn-clear" onclick="clearBackgroundColor()">Clear Background Color</button>
             </div>
            
            <div class="form-group">
              <label for="customBgColor">Custom Background Color</label>
              <input type="color" id="customBgColor" value="#ffffff">
            </div>
            
            <div class="form-group">
              <label for="gradientBgEnabled">Gradient Background</label>
              <select id="gradientBgEnabled">
                <option value="false">Single Color</option>
                <option value="true">Gradient</option>
              </select>
            </div>
            
            <div class="form-group" id="gradientControls" style="display: none;">
              <label for="gradientColor1">Gradient Color 1</label>
              <input type="color" id="gradientColor1" value="#AC1A2F">
            </div>
            
            <div class="form-group" id="gradientControls2" style="display: none;">
              <label for="gradientColor2">Gradient Color 2</label>
              <input type="color" id="gradientColor2" value="#8b0000">
            </div>
            
            <div class="form-group" id="gradientControls3" style="display: none;">
              <label for="gradientColor3">Gradient Color 3</label>
              <input type="color" id="gradientColor3" value="#660000">
            </div>
            
            <div class="form-group" id="gradientControls4" style="display: none;">
              <label for="gradientDirection">Gradient Direction</label>
              <select id="gradientDirection">
                <option value="135deg">Diagonal (135°)</option>
                <option value="90deg">Vertical</option>
                <option value="0deg">Horizontal</option>
                <option value="45deg">Diagonal (45°)</option>
                <option value="180deg">Diagonal (180°)</option>
              </select>
            </div>
            </div>
          </div>

          <!-- Images Section -->
          <div class="control-section">
            <div class="section-header" onclick="toggleSection('imagesSection')">
              <h3>Images</h3>
              <span class="section-toggle" id="imagesToggle">▼</span>
            </div>
            <div class="section-content" id="imagesSection">
            <div class="form-group">
              <label for="bgUpload">Background Image</label>
              <input type="file" id="bgUpload" accept="image/*">
              <button class="btn-remove" onclick="removeBgImage()">Remove Background</button>
            </div>
            
            <!-- Unsplash Integration -->
            <div class="form-group">
              <label>Or choose from Unsplash</label>
              <div class="unsplash-search">
                <input type="text" id="unsplashSearch" placeholder="Search for images (e.g., nature, business, abstract)">
                <button type="button" id="searchUnsplash" class="btn btn-primary btn-sm">Search</button>
                <button type="button" id="randomUnsplash" class="btn btn-secondary btn-sm">Random</button>
              </div>
              <div id="unsplashResults" class="unsplash-grid" style="display: none;">
                <!-- Unsplash images will be loaded here -->
              </div>
              <div id="unsplashLoading" style="display: none;">
                <p>Loading images...</p>
              </div>
            </div>
            
            <!-- Background Image Controls (shown when image is uploaded) -->
            <div id="bgImageControls" style="display: none;">
              <div class="form-group">
                <label for="bgImageFit">Image Fit</label>
                <select id="bgImageFit">
                  <option value="cover">Cover (Fill Banner)</option>
                  <option value="contain">Contain (Fit Entire Image)</option>
                  <option value="fill">Fill (Stretch)</option>
                  <option value="none">None (Original Size)</option>
                </select>
              </div>
              
              <div class="form-group">
                <label for="bgImagePosition">Image Position</label>
                <select id="bgImagePosition">
                  <option value="center">Center</option>
                  <option value="top">Top</option>
                  <option value="bottom">Bottom</option>
                  <option value="left">Left</option>
                  <option value="right">Right</option>
                  <option value="top left">Top Left</option>
                  <option value="top right">Top Right</option>
                  <option value="bottom left">Bottom Left</option>
                  <option value="bottom right">Bottom Right</option>
                </select>
              </div>
              
              <div class="form-group">
                <label for="bgImageXOffset">Horizontal Position (-50 to 50)</label>
                <input type="range" id="bgImageXOffset" value="0" min="-50" max="50" step="1">
                <span id="bgImageXOffsetValue">0</span>
              </div>
              
              <div class="form-group">
                <label for="bgImageYOffset">Vertical Position (-50 to 50)</label>
                <input type="range" id="bgImageYOffset" value="0" min="-50" max="50" step="1">
                <span id="bgImageYOffsetValue">0</span>
              </div>
              
              <div class="form-group">
                <button type="button" id="resetBgImagePosition" class="btn btn-secondary btn-sm">
                  Reset Position
                </button>
              </div>
              
              <div class="form-group">
                <label>Quick Position Controls</label>
                <div class="position-controls">
                  <button type="button" id="bgImageUp" class="btn btn-sm">↑</button>
                  <button type="button" id="bgImageDown" class="btn btn-sm">↓</button>
                  <button type="button" id="bgImageLeft" class="btn btn-sm">←</button>
                  <button type="button" id="bgImageRight" class="btn btn-sm">→</button>
                </div>
              </div>
              
              <div class="form-group">
                <label for="bgImageScale">Image Scale (%)</label>
                <input type="range" id="bgImageScale" value="100" min="50" max="200" step="10">
                <span id="bgImageScaleValue">100%</span>
              </div>
              
              <div class="form-group">
                <label for="bgImageOpacity">Image Opacity</label>
                <input type="range" id="bgImageOpacity" value="85" min="10" max="100" step="5">
                <span id="bgImageOpacityValue">85%</span>
              </div>
            </div>
            

             
                                                       <div class="form-group">
                 <label for="logoUpload">Logo Upload (Right Side)</label>
                 <input type="file" id="logoUpload" accept="image/*">
                 <button class="btn-remove" onclick="removeLogo()">Remove Logo</button>
               </div>
               
               <div class="form-group">
                 <label for="logoType">Logo Type</label>
                 <select id="logoType">
                   <option value="upload">Upload Image</option>
                   <option value="icon">Icon/Emoji</option>
                 </select>
               </div>
               
               <div class="form-group" id="iconControls" style="display: none;">
                 <label for="iconEmoji">Icon/Emoji</label>
                 <input type="text" id="iconEmoji" placeholder="🎓" value="🎓">
                 <div class="emoji-suggestions">
                   <span class="emoji-option" onclick="selectEmoji('🎓')">🎓</span>
                   <span class="emoji-option" onclick="selectEmoji('📚')">📚</span>
                   <span class="emoji-option" onclick="selectEmoji('💡')">💡</span>
                   <span class="emoji-option" onclick="selectEmoji('🔬')">🔬</span>
                   <span class="emoji-option" onclick="selectEmoji('🎨')">🎨</span>
                   <span class="emoji-option" onclick="selectEmoji('💻')">💻</span>
                   <span class="emoji-option" onclick="selectEmoji('🏥')">🏥</span>
                   <span class="emoji-option" onclick="selectEmoji('⚙️')">⚙️</span>
                   <span class="emoji-option" onclick="selectEmoji('🌟')">🌟</span>
                   <span class="emoji-option" onclick="selectEmoji('🎯')">🎯</span>
                 </div>
               </div>
               
               <div class="form-group" id="iconColorControl" style="display: none;">
                 <label for="iconColor">Icon Color</label>
                 <input type="color" id="iconColor" value="#ffffff">
               </div>
              
              <div class="form-group">
                <label>Logo Size</label>
                <div class="logo-controls">
                  <label>Size:</label>
                  <input type="range" id="logoSize" value="120" min="40" max="300" step="10">
                  <span id="logoSizeValue">120px</span>
                </div>
              </div>
              

            </div>
          </div>
          
          <!-- Decorative Shapes Section -->
          <div class="control-section">
            <div class="section-header" onclick="toggleSection('shapeSection')">
              <h3>Decorative Shapes</h3>
              <span class="section-toggle" id="shapeToggle">▼</span>
            </div>
            <div class="section-content" id="shapeSection">
              <div class="form-group">
                <label for="shapeType">Shape Type</label>
                <select id="shapeType">
                  <option value="">No Shape</option>
                  <option value="block-left">Left Accent Bar</option>
                  <option value="block-right">Right Accent Bar</option>
                  <option value="block-top">Top Accent Bar</option>
                  <option value="block-bottom">Bottom Accent Bar</option>
                  <option value="block-wide-left">Wide Left Bar</option>
                  <option value="block-wide-right">Wide Right Bar</option>
                  <option value="block-wide-top">Wide Top Bar</option>
                  <option value="block-wide-bottom">Wide Bottom Bar</option>
                  <option value="block-corner-tl">Top Left Corner</option>
                  <option value="block-corner-tr">Top Right Corner</option>
                  <option value="block-corner-bl">Bottom Left Corner</option>
                  <option value="block-corner-br">Bottom Right Corner</option>
                  <option value="block-center">Center Block</option>
                  <option value="block-center-left">Center Left</option>
                  <option value="block-center-right">Center Right</option>
                  <option value="block-center-top">Center Top</option>
                  <option value="block-center-bottom">Center Bottom</option>
                  <option value="block-diagonal">Diagonal Bar</option>
                  <option value="block-diagonal-reverse">Diagonal Bar (Reverse)</option>
                  <option value="block-circle">Circle</option>
                  <option value="block-oval">Oval</option>
                  <option value="block-triangle">Triangle</option>
                  <option value="block-diamond">Diamond</option>
                  <option value="block-hexagon">Hexagon</option>
                </select>
              </div>
              
                                <div class="form-group">
                    <label for="shapeColor">Shape Color</label>
                    <input type="color" id="shapeColor" value="#ffffff">
                  </div>
                  
                  <div class="form-group">
                    <label for="shapeGradientEnabled">Enable Shape Gradient</label>
                    <input type="checkbox" id="shapeGradientEnabled">
                  </div>
                  
                  <div class="form-group" id="shapeGradientControls" style="display: none;">
                    <label for="shapeGradientColor1">Gradient Color 1</label>
                    <input type="color" id="shapeGradientColor1" value="#ffffff">
                    
                    <label for="shapeGradientColor2">Gradient Color 2</label>
                    <input type="color" id="shapeGradientColor2" value="#cccccc">
                    
                    <label for="shapeGradientDirection">Gradient Direction</label>
                    <select id="shapeGradientDirection">
                      <option value="to right">Horizontal</option>
                      <option value="to bottom">Vertical</option>
                      <option value="45deg">Diagonal</option>
                      <option value="135deg">Diagonal (Reverse)</option>
                    </select>
                  </div>
              
              <div class="form-group">
                <label for="shapeSize">Shape Size</label>
                <input type="range" id="shapeSize" value="20" min="5" max="300" step="5">
                <span id="shapeSizeValue">20px</span>
              </div>
              
              <div class="form-group">
                <label for="shapeOpacity">Shape Opacity</label>
                <input type="range" id="shapeOpacity" value="100" min="10" max="100" step="10">
                <span id="shapeOpacityValue">100%</span>
              </div>
              
              <div class="form-group">
                <label for="shapePosition">Shape Position</label>
                <select id="shapePosition">
                  <option value="default">Default</option>
                  <option value="inset">Inset</option>
                  <option value="outset">Outset</option>
                </select>
              </div>
              
              <div class="form-group">
                <label for="shapeImageEnabled">Fill Shape with Image</label>
                <input type="checkbox" id="shapeImageEnabled">
              </div>
              
              <div class="form-group" id="shapeImageControls" style="display: none;">
                <label for="shapeImageUpload">Upload Shape Image</label>
                <input type="file" id="shapeImageUpload" accept="image/*">
                <button type="button" onclick="removeShapeImage()" class="btn btn-sm">Remove Image</button>
              </div>
            </div>
          </div>

                     <!-- Export Options -->
           <div class="control-section">
             <div class="section-header" onclick="toggleSection('exportOptionsSection')">
               <h3>Export Options</h3>
               <span class="section-toggle" id="exportOptionsToggle">▼</span>
             </div>
             <div class="section-content" id="exportOptionsSection">
             <div class="form-group">
               <label for="exportFileName">File Name</label>
               <input type="text" id="exportFileName" value="canvas-banner" placeholder="Enter file name (without extension)">
             </div>
             
             <div class="form-group">
               <label for="exportQuality">Quality & Resolution</label>
               <select id="exportQuality">
                 <option value="1.0">Ultra High Quality (4x Resolution)</option>
                 <option value="0.9">High Quality (3x Resolution)</option>
                 <option value="0.8" selected>Standard Quality (2x Resolution)</option>
                 <option value="0.6">Basic Quality (1.5x Resolution)</option>
               </select>
             </div>
             
             <div class="form-group">
               <label for="exportSize">Export Size</label>
               <select id="exportSize">
                 <option value="original">Original Size</option>
                 <option value="canvas-optimal" selected>Canvas Optimal (1200x200)</option>
                 <option value="canvas-card">Canvas Card (262x147)</option>
                 <option value="high-res">High Resolution (2400x400)</option>
                 <option value="web-optimized">Web Optimized (800x133)</option>
               </select>
             </div>
             
             <div class="export-buttons">
               <button class="btn btn-primary" onclick="bannerCreator.downloadBanner()">Download PNG</button>
               <button class="btn btn-secondary" onclick="bannerCreator.exportAsPDF()">Export PDF</button>
               <button class="btn btn-secondary" onclick="bannerCreator.exportAsJPG()">Export JPG</button>
               <button class="btn btn-secondary" onclick="bannerCreator.exportAsWebP()">Export WebP</button>
               <button class="btn btn-secondary" onclick="bannerCreator.exportAsSVG()">Export SVG</button>
               <button class="btn btn-secondary" onclick="bannerCreator.exportAsHTML()">Export HTML</button>
               <button class="btn btn-secondary" onclick="bannerCreator.copyToClipboard()">Copy to Clipboard</button>
             </div>
             </div>
           </div>
        </div>
      </div>
    </div>
    
    <!-- Bottom padding spacer -->
    <div style="height: 100px;"></div>
  </div>

  <script>
    // Banner Creator Class
    class BannerCreator {
      constructor() {
        this.initializeElements();
        this.bindEvents();
        this.updateBanner();
      }

      initializeElements() {
                 // Input elements
                  this.inputs = {
            title: document.getElementById('title'),
            subtitle2: document.getElementById('subtitle2'),
            subtitle3: document.getElementById('subtitle3'),
            titleSize: document.getElementById('titleSize'),
            subtitleSize: document.getElementById('subtitleSize'),
            titleColor: document.getElementById('titleColor'),
            subtitleColor: document.getElementById('subtitleColor'),
            subtitle3Color: document.getElementById('subtitle3Color'),
            bannerWidth: document.getElementById('bannerWidth'),
            bannerHeight: document.getElementById('bannerHeight'),
            previewScale: document.getElementById('previewScale'),
            fontChoice: document.getElementById('fontChoice'),
            textAlign: document.getElementById('textAlign'),
            sinclairColor: document.getElementById('sinclairColor'),
            customBgColor: document.getElementById('customBgColor'),
            bgUpload: document.getElementById('bgUpload'),
            bgImageFit: document.getElementById('bgImageFit'),
            bgImagePosition: document.getElementById('bgImagePosition'),
            bgImageXOffset: document.getElementById('bgImageXOffset'),
            bgImageYOffset: document.getElementById('bgImageYOffset'),
            bgImageScale: document.getElementById('bgImageScale'),
            bgImageOpacity: document.getElementById('bgImageOpacity'),

            logoUpload: document.getElementById('logoUpload'),
            logoType: document.getElementById('logoType'),
            iconEmoji: document.getElementById('iconEmoji'),
            iconColor: document.getElementById('iconColor'),
            logoSize: document.getElementById('logoSize'),
            shapeType: document.getElementById('shapeType'),
            shapeColor: document.getElementById('shapeColor'),
            shapeGradientEnabled: document.getElementById('shapeGradientEnabled'),
            shapeGradientColor1: document.getElementById('shapeGradientColor1'),
            shapeGradientColor2: document.getElementById('shapeGradientColor2'),
            shapeGradientDirection: document.getElementById('shapeGradientDirection'),
            shapeSize: document.getElementById('shapeSize'),
            shapeOpacity: document.getElementById('shapeOpacity'),
            shapePosition: document.getElementById('shapePosition'),
            shapeImageEnabled: document.getElementById('shapeImageEnabled'),
            shapeImageUpload: document.getElementById('shapeImageUpload'),
            gradientBgEnabled: document.getElementById('gradientBgEnabled'),
            gradientColor1: document.getElementById('gradientColor1'),
            gradientColor2: document.getElementById('gradientColor2'),
            gradientColor3: document.getElementById('gradientColor3'),
            gradientDirection: document.getElementById('gradientDirection'),
            exportFileName: document.getElementById('exportFileName'),
            exportQuality: document.getElementById('exportQuality'),
            exportSize: document.getElementById('exportSize'),
            unsplashSearch: document.getElementById('unsplashSearch'),
            searchUnsplash: document.getElementById('searchUnsplash'),
            randomUnsplash: document.getElementById('randomUnsplash')
          };

                 // Preview elements
         this.preview = {
           banner: document.getElementById('bannerPreview'),
           title: document.getElementById('bannerTitle'),
           subtitle2: document.getElementById('bannerSubtitle2'),
           subtitle3: document.getElementById('bannerSubtitle3'),
          textContainer: document.getElementById('bannerTextContainer'),
          bgImage: document.getElementById('bgImage'),
          logoImage: document.getElementById('logoImage'),
          logoIcon: document.getElementById('logoIcon'),
          shapeElement: document.getElementById('shapeElement')
        };

        this.messageContainer = document.getElementById('messageContainer');
        this.scaleValue = document.getElementById('scaleValue');
        this.logoSizeValue = document.getElementById('logoSizeValue');
        this.bgImageControls = document.getElementById('bgImageControls');
        this.bgImageScaleValue = document.getElementById('bgImageScaleValue');
        this.bgImageOpacityValue = document.getElementById('bgImageOpacityValue');
        this.bgImageXOffsetValue = document.getElementById('bgImageXOffsetValue');
        this.bgImageYOffsetValue = document.getElementById('bgImageYOffsetValue');
        this.resetBgImagePosition = document.getElementById('resetBgImagePosition');
        
        // Background image arrow controls
        this.bgImageUp = document.getElementById('bgImageUp');
        this.bgImageDown = document.getElementById('bgImageDown');
        this.bgImageLeft = document.getElementById('bgImageLeft');
        this.bgImageRight = document.getElementById('bgImageRight');
        this.gradientControls = document.getElementById('gradientControls');
        this.gradientControls2 = document.getElementById('gradientControls2');
        this.gradientControls3 = document.getElementById('gradientControls3');
        this.gradientControls4 = document.getElementById('gradientControls4');
        this.iconControls = document.getElementById('iconControls');
        this.iconColorControl = document.getElementById('iconColorControl');
      }

             bindEvents() {
                            // Text and styling inputs
         const textInputs = ['title', 'subtitle2', 'subtitle3', 'titleSize', 'subtitleSize', 'titleColor', 'subtitleColor', 'subtitle3Color', 'bannerWidth', 'bannerHeight', 'fontChoice', 'textAlign'];
          textInputs.forEach(id => {
            this.inputs[id].addEventListener('input', () => this.updateBanner());
          });


          
          // Custom logo upload
          this.inputs.logoUpload.addEventListener('change', (e) => this.handleCustomLogoUpload(e));
          
          // Shape controls
          this.inputs.shapeType.addEventListener('change', () => this.updateShape());
          this.inputs.shapeColor.addEventListener('input', () => this.updateShape());
          this.inputs.shapeSize.addEventListener('input', () => this.updateShape());
          this.inputs.shapeOpacity.addEventListener('input', () => this.updateShape());
          this.inputs.shapePosition.addEventListener('change', () => this.updateShape());
          
          // Shape gradient controls
          if (this.inputs.shapeGradientEnabled) {
            this.inputs.shapeGradientEnabled.addEventListener('change', () => this.toggleShapeGradientControls());
          }
          if (this.inputs.shapeGradientColor1) {
            this.inputs.shapeGradientColor1.addEventListener('input', () => this.updateShape());
          }
          if (this.inputs.shapeGradientColor2) {
            this.inputs.shapeGradientColor2.addEventListener('input', () => this.updateShape());
          }
          if (this.inputs.shapeGradientDirection) {
            this.inputs.shapeGradientDirection.addEventListener('change', () => this.updateShape());
          }
          
          // Shape image controls
          if (this.inputs.shapeImageEnabled) {
            this.inputs.shapeImageEnabled.addEventListener('change', () => this.toggleShapeImageControls());
          }
          if (this.inputs.shapeImageUpload) {
            this.inputs.shapeImageUpload.addEventListener('change', (e) => this.handleShapeImageUpload(e));
          }

         // Sinclair color dropdown
         this.inputs.sinclairColor.addEventListener('change', () => {
           console.log('Sinclair color changed to:', this.inputs.sinclairColor.value);
           // If a Sinclair color is selected, clear the custom color picker
           if (this.inputs.sinclairColor.value !== '') {
             this.inputs.customBgColor.value = '#ffffff';
           }
           console.log('Calling updateBanner from Sinclair color change');
           this.updateBanner();
         });
         
         // Also add a click listener as backup
         this.inputs.sinclairColor.addEventListener('click', () => {
           console.log('Sinclair color clicked');
         });
         
         // Add a test to check if the dropdown is working
         setTimeout(() => {
           console.log('Sinclair dropdown options:', this.inputs.sinclairColor.options.length);
           console.log('Sinclair dropdown current value:', this.inputs.sinclairColor.value);
         }, 1000);

         // Custom color picker
         this.inputs.customBgColor.addEventListener('input', () => {
           console.log('Custom color changed to:', this.inputs.customBgColor.value);
           // If custom color is used, set Sinclair dropdown to "Custom Color"
           this.inputs.sinclairColor.value = '';
           console.log('Calling updateBanner from custom color change');
           this.updateBanner();
         });

         // Preview scale
         this.inputs.previewScale.addEventListener('input', () => {
           this.updatePreviewScale();
         });
         
                   // Logo size
          this.inputs.logoSize.addEventListener('input', () => {
            this.updateLogoSize();
          });

         // File uploads
         this.inputs.bgUpload.addEventListener('change', (e) => this.handleImageUpload(e, 'bgImage'));
         this.inputs.logoUpload.addEventListener('change', (e) => this.handleImageUpload(e, 'logoImage'));
         
         // Unsplash integration
         if (this.inputs.searchUnsplash) {
           this.inputs.searchUnsplash.addEventListener('click', () => this.searchUnsplash());
         }
         if (this.inputs.randomUnsplash) {
           this.inputs.randomUnsplash.addEventListener('click', () => this.getRandomUnsplash());
         }
         if (this.inputs.unsplashSearch) {
           this.inputs.unsplashSearch.addEventListener('keypress', (e) => {
             if (e.key === 'Enter') {
               this.searchUnsplash();
             }
           });
         }
         
         // Background image controls
         if (this.inputs.bgImageFit) {
           this.inputs.bgImageFit.addEventListener('change', () => this.updateBanner());
         }
         if (this.inputs.bgImagePosition) {
           this.inputs.bgImagePosition.addEventListener('change', () => this.resetBgImageOffsets());
         }
         if (this.inputs.bgImageXOffset) {
           this.inputs.bgImageXOffset.addEventListener('input', () => this.updateBgImageXOffset());
         }
         if (this.inputs.bgImageYOffset) {
           this.inputs.bgImageYOffset.addEventListener('input', () => this.updateBgImageYOffset());
         }
         if (this.inputs.bgImageScale) {
           this.inputs.bgImageScale.addEventListener('input', () => this.updateBgImageScale());
         }
         if (this.inputs.bgImageOpacity) {
           this.inputs.bgImageOpacity.addEventListener('input', () => this.updateBgImageOpacity());
         }
         if (this.resetBgImagePosition) {
           this.resetBgImagePosition.addEventListener('click', () => this.resetBgImageOffsets());
         }
         
         // Background image arrow controls
         if (this.bgImageUp) {
           this.bgImageUp.addEventListener('click', () => this.moveBgImageUp());
         }
         if (this.bgImageDown) {
           this.bgImageDown.addEventListener('click', () => this.moveBgImageDown());
         }
         if (this.bgImageLeft) {
           this.bgImageLeft.addEventListener('click', () => this.moveBgImageLeft());
         }
         if (this.bgImageRight) {
           this.bgImageRight.addEventListener('click', () => this.moveBgImageRight());
         }
         
         // Gradient background controls
         if (this.inputs.gradientBgEnabled) {
           this.inputs.gradientBgEnabled.addEventListener('change', () => this.toggleGradientControls());
         }
         if (this.inputs.gradientColor1) {
           this.inputs.gradientColor1.addEventListener('input', () => this.updateBanner());
         }
         if (this.inputs.gradientColor2) {
           this.inputs.gradientColor2.addEventListener('input', () => this.updateBanner());
         }
         if (this.inputs.gradientColor3) {
           this.inputs.gradientColor3.addEventListener('input', () => this.updateBanner());
         }
         if (this.inputs.gradientDirection) {
           this.inputs.gradientDirection.addEventListener('change', () => this.updateBanner());
         }
         
         // Interactive background image positioning
         this.initializeBackgroundImagePositioning();
         
         // Icon controls
         this.initializeIconControls();
         
         // Show new features popup on first load
         this.showNewFeaturesPopupOnLoad();
       }
       
       initializeBackgroundImagePositioning() {
         const bgImage = this.preview.bgImage;
         const bannerPreview = this.preview.banner;
         const cropOverlay = document.getElementById('cropOverlay');
         const cropWindow = document.getElementById('cropWindow');
         
         // Show crop interface when background image is loaded
         const showCropInterface = () => {
           if (bgImage.style.display !== 'none' && bgImage.src) {
             cropOverlay.style.display = 'block';
             
             // Set crop window size to match banner dimensions
             const bannerRect = bannerPreview.getBoundingClientRect();
             cropWindow.style.width = `${bannerRect.width}px`;
             cropWindow.style.height = `${bannerRect.height}px`;
             cropWindow.style.left = '0px';
             cropWindow.style.top = '0px';
           } else {
             cropOverlay.style.display = 'none';
           }
         };
         
         // Handle click to position image
         cropOverlay.addEventListener('click', (e) => {
           if (bgImage.style.display !== 'none' && bgImage.src) {
             const rect = cropOverlay.getBoundingClientRect();
             const clickX = e.clientX - rect.left;
             const clickY = e.clientY - rect.top;
             
             // Calculate position as percentage
             const xPercent = (clickX / rect.width) * 100;
             const yPercent = (clickY / rect.height) * 100;
             
             // Apply object-position to center the image at click point
             bgImage.style.objectPosition = `${xPercent}% ${yPercent}%`;
             
             // Update offset controls
             const xOffset = Math.round((xPercent - 50) * 2); // Convert to -50 to +50 range
             const yOffset = Math.round((yPercent - 50) * 2);
             
             if (this.inputs.bgImageXOffset) {
               this.inputs.bgImageXOffset.value = Math.max(-50, Math.min(50, xOffset));
               if (this.bgImageXOffsetValue) {
                 this.bgImageXOffsetValue.textContent = this.inputs.bgImageXOffset.value;
               }
             }
             
             if (this.inputs.bgImageYOffset) {
               this.inputs.bgImageYOffset.value = Math.max(-50, Math.min(50, yOffset));
               if (this.bgImageYOffsetValue) {
                 this.bgImageYOffsetValue.textContent = this.inputs.bgImageYOffset.value;
               }
             }
           }
         });
         
         // Show crop interface when image is loaded
         bgImage.addEventListener('load', showCropInterface);
         
         // Initial setup
         showCropInterface();
       }

       initializeIconControls() {
         // Logo type toggle
         if (this.inputs.logoType) {
           this.inputs.logoType.addEventListener('change', () => {
             this.toggleIconControls();
             this.updateBanner();
           });
         }
         
         // Icon emoji input
         if (this.inputs.iconEmoji) {
           this.inputs.iconEmoji.addEventListener('input', () => {
             this.updateBanner();
           });
         }
         
         // Icon color picker
         if (this.inputs.iconColor) {
           this.inputs.iconColor.addEventListener('input', () => {
             this.updateBanner();
           });
         }
       }

       toggleIconControls() {
         const logoType = this.inputs.logoType ? this.inputs.logoType.value : 'upload';
         
         if (this.iconControls) {
           this.iconControls.style.display = logoType === 'icon' ? 'block' : 'none';
         }
         if (this.iconColorControl) {
           this.iconColorControl.style.display = logoType === 'icon' ? 'block' : 'none';
         }
         
         // Hide/show logo upload based on type
         if (this.inputs.logoUpload) {
           this.inputs.logoUpload.parentElement.style.display = logoType === 'upload' ? 'block' : 'none';
         }
       }
       
       showNewFeaturesPopupOnLoad() {
         // Check if this is the first time visiting (using localStorage)
         const hasSeenPopup = localStorage.getItem('bannerCreatorNewFeaturesSeen');
         
         if (!hasSeenPopup) {
           // Show popup after a short delay to ensure page is loaded
           setTimeout(() => {
             showNewFeaturesPopup();
             // Mark as seen
             localStorage.setItem('bannerCreatorNewFeaturesSeen', 'true');
           }, 1000);
         }
       }
       
       updateOffsetControlsFromDrag(dragX, dragY) {
         // Convert pixel drag position to offset values (-50 to 50 range)
         const bannerRect = this.preview.banner.getBoundingClientRect();
         const xOffset = Math.round((dragX / bannerRect.width) * 100);
         const yOffset = Math.round((dragY / bannerRect.height) * 100);
         
         // Update the offset controls if they exist
         if (this.inputs.bgImageXOffset) {
           this.inputs.bgImageXOffset.value = Math.max(-50, Math.min(50, xOffset));
           if (this.bgImageXOffsetValue) {
             this.bgImageXOffsetValue.textContent = this.inputs.bgImageXOffset.value;
           }
         }
         
         if (this.inputs.bgImageYOffset) {
           this.inputs.bgImageYOffset.value = Math.max(-50, Math.min(50, yOffset));
           if (this.bgImageYOffsetValue) {
             this.bgImageYOffsetValue.textContent = this.inputs.bgImageYOffset.value;
           }
         }
       }
       
       updateOffsetControlsFromZoomPan(panX, panY, scale) {
         // Convert percentage pan position to offset values (-50 to 50 range)
         // Since the image is 200% size, we need to convert the percentage movement
         const xOffset = Math.round((panX + 25) * 2); // Convert from -25% to +25% range to -50 to +50
         const yOffset = Math.round((panY + 25) * 2);
         
         // Update the offset controls if they exist
         if (this.inputs.bgImageXOffset) {
           this.inputs.bgImageXOffset.value = Math.max(-50, Math.min(50, xOffset));
           if (this.bgImageXOffsetValue) {
             this.bgImageXOffsetValue.textContent = this.inputs.bgImageXOffset.value;
           }
         }
         
         if (this.inputs.bgImageYOffset) {
           this.inputs.bgImageYOffset.value = Math.max(-50, Math.min(50, yOffset));
           if (this.bgImageYOffsetValue) {
             this.bgImageYOffsetValue.textContent = this.inputs.bgImageYOffset.value;
           }
         }
       }

                                                       handleImageUpload(event, imageType) {
           const file = event.target.files[0];
           if (file) {
             const reader = new FileReader();
             reader.onload = (e) => {
               this.preview[imageType].src = e.target.result;
               this.preview[imageType].style.display = 'block';
               
               // If uploading a custom logo, clear the logo choice dropdown
               if (imageType === 'logoImage') {
                 this.inputs.logoChoice.value = '';
               }
               
               // Show background image controls if background image is uploaded
               if (imageType === 'bgImage') {
                 this.bgImageControls.style.display = 'block';
               }
               
               this.showMessage(`✅ ${imageType === 'bgImage' ? 'Background' : 'Logo'} image uploaded successfully!`, 'success');
               
               // Update placeholder visibility after image upload
               this.updateBanner();
             };
             
             reader.onerror = () => {
               console.error('Error reading file:', file.name);
               this.showMessage(`❌ Error reading ${imageType === 'bgImage' ? 'background' : 'logo'} image file`, 'error');
             };
             
             reader.readAsDataURL(file);
                    }
       }
       
       // Unsplash API functions
       async searchUnsplash() {
         const query = this.inputs.unsplashSearch.value.trim();
         if (!query) {
           this.showMessage('Please enter a search term', 'error');
           return;
         }
         
         this.showUnsplashLoading(true);
         
         try {
           const response = await fetch(`https://api.unsplash.com/search/photos?query=${encodeURIComponent(query)}&per_page=12&orientation=landscape`, {
             headers: {
               'Authorization': 'Client-ID 5u_U6reEyqaO7fFjIzkZzjpI_RjJmeLzikHd6WFjeTg'
             }
           });
           
           if (!response.ok) {
             throw new Error('Failed to fetch images');
           }
           
           const data = await response.json();
           this.displayUnsplashResults(data.results);
         } catch (error) {
           console.error('Error fetching Unsplash images:', error);
           this.showMessage('Error fetching images. Please try again.', 'error');
           this.showDemoImages();
         } finally {
           this.showUnsplashLoading(false);
         }
       }
       
       async getRandomUnsplash() {
         this.showUnsplashLoading(true);
         
         try {
           const response = await fetch('https://api.unsplash.com/photos/random?count=12&orientation=landscape', {
             headers: {
               'Authorization': 'Client-ID 5u_U6reEyqaO7fFjIzkZzjpI_RjJmeLzikHd6WFjeTg'
             }
           });
           
           if (!response.ok) {
             throw new Error('Failed to fetch random images');
           }
           
           const data = await response.json();
           this.displayUnsplashResults(data);
         } catch (error) {
           console.error('Error fetching random Unsplash images:', error);
           this.showMessage('Error fetching images. Please try again.', 'error');
           this.showDemoImages();
         } finally {
           this.showUnsplashLoading(false);
         }
       }
       
       displayUnsplashResults(images) {
         const resultsContainer = document.getElementById('unsplashResults');
         resultsContainer.innerHTML = '';
         
         images.forEach(image => {
           const imgElement = document.createElement('img');
           imgElement.src = image.urls.small;
           imgElement.alt = image.alt_description || 'Unsplash image';
           imgElement.className = 'unsplash-image';
           imgElement.dataset.fullUrl = image.urls.regular;
           imgElement.dataset.thumbUrl = image.urls.small;
           
           imgElement.addEventListener('click', () => this.selectUnsplashImage(imgElement));
           resultsContainer.appendChild(imgElement);
         });
         
         resultsContainer.style.display = 'grid';
       }
       
       selectUnsplashImage(imgElement) {
         // Remove selection from other images
         document.querySelectorAll('.unsplash-image').forEach(img => img.classList.remove('selected'));
         
         // Select this image
         imgElement.classList.add('selected');
         
         // Set as background image
         this.preview.bgImage.src = imgElement.dataset.fullUrl;
         this.preview.bgImage.style.display = 'block';
         this.bgImageControls.style.display = 'block';
         
         this.showMessage('✅ Unsplash image selected as background!', 'success');
       }
       
       showUnsplashLoading(show) {
         const loadingElement = document.getElementById('unsplashLoading');
         const resultsElement = document.getElementById('unsplashResults');
         
         if (show) {
           loadingElement.style.display = 'block';
           resultsElement.style.display = 'none';
         } else {
           loadingElement.style.display = 'none';
         }
       }
       
       showDemoImages() {
         // Demo images for when API is not available
         const demoImages = [
           'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=300&fit=crop',
           'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=400&h=300&fit=crop',
           'https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400&h=300&fit=crop',
           'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=300&fit=crop',
           'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=400&h=300&fit=crop',
           'https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400&h=300&fit=crop'
         ];
         
         const resultsContainer = document.getElementById('unsplashResults');
         resultsContainer.innerHTML = '';
         
         demoImages.forEach((url, index) => {
           const imgElement = document.createElement('img');
           imgElement.src = url;
           imgElement.alt = `Demo image ${index + 1}`;
           imgElement.className = 'unsplash-image';
           imgElement.dataset.fullUrl = url;
           
           imgElement.addEventListener('click', () => this.selectUnsplashImage(imgElement));
           resultsContainer.appendChild(imgElement);
         });
         
         resultsContainer.style.display = 'grid';
       }

                             
       
       handleCustomLogoUpload(event) {
         const file = event.target.files[0];
         if (file) {
           const reader = new FileReader();
           reader.onload = (e) => {
             this.preview.logoImage.src = e.target.result;
             this.preview.logoImage.style.display = 'block';
             this.showMessage('✅ Custom logo uploaded successfully!', 'success');
             this.updateBanner();
           };
           reader.onerror = () => {
             this.showMessage('❌ Error reading logo file', 'error');
           };
           reader.readAsDataURL(file);
         }
       }

                                  removeBgImage() {
         this.preview.bgImage.src = '';
         this.preview.bgImage.style.display = 'none';
         this.preview.bgImage.alt = '';
         this.preview.bgImage.style.objectPosition = 'center center'; // Reset position
         this.inputs.bgUpload.value = '';
         this.bgImageControls.style.display = 'none';
         this.updateBanner(); // Force banner update
         this.showMessage('🗑️ Background image removed', 'success');
       }

       removeLogo() {
         console.log('removeLogo called');
         
         // Clear logo image completely
         this.preview.logoImage.src = '';
         this.preview.logoImage.style.display = 'none';
         this.preview.logoImage.alt = '';
         this.preview.logoImage.style.opacity = '0';
         this.preview.logoImage.style.visibility = 'hidden';
         
         // Clear form inputs
         this.inputs.logoUpload.value = '';
         
         // Force banner update
         this.updateBanner();
         
         // Double-check logo is hidden
         setTimeout(() => {
           this.preview.logoImage.style.display = 'none';
           this.preview.logoImage.src = '';
         }, 100);
         
         this.showMessage('🗑️ Logo removed', 'success');
       }
       
       updateShape() {
         const shapeType = this.inputs.shapeType && this.inputs.shapeType.value ? this.inputs.shapeType.value : '';
         const shapeColor = this.inputs.shapeColor && this.inputs.shapeColor.value ? this.inputs.shapeColor.value : '#ffffff';
         const shapeSize = this.inputs.shapeSize && this.inputs.shapeSize.value ? parseInt(this.inputs.shapeSize.value) : 20;
         const shapeOpacity = this.inputs.shapeOpacity && this.inputs.shapeOpacity.value ? parseInt(this.inputs.shapeOpacity.value) : 100;
         const shapePosition = this.inputs.shapePosition && this.inputs.shapePosition.value ? this.inputs.shapePosition.value : 'default';
         
         // Update size display
         if (this.inputs.shapeSizeValue) {
           this.inputs.shapeSizeValue.textContent = `${shapeSize}px`;
         }
         if (this.inputs.shapeOpacityValue) {
           this.inputs.shapeOpacityValue.textContent = `${shapeOpacity}%`;
         }
         
         if (shapeType && shapeType !== '') {
           // Show shape element
           this.preview.shapeElement.style.display = 'block';
           this.preview.shapeElement.className = `block-${shapeType.split('-')[1]}`;
           this.preview.shapeElement.style.opacity = shapeOpacity / 100;
           
           // Handle gradient or solid color
           const useGradient = this.inputs.shapeGradientEnabled && this.inputs.shapeGradientEnabled.checked;
           if (useGradient) {
             const gradientColor1 = this.inputs.shapeGradientColor1 && this.inputs.shapeGradientColor1.value ? this.inputs.shapeGradientColor1.value : '#ffffff';
             const gradientColor2 = this.inputs.shapeGradientColor2 && this.inputs.shapeGradientColor2.value ? this.inputs.shapeGradientColor2.value : '#cccccc';
             const gradientDirection = this.inputs.shapeGradientDirection && this.inputs.shapeGradientDirection.value ? this.inputs.shapeGradientDirection.value : 'to right';
             
             this.preview.shapeElement.style.background = `linear-gradient(${gradientDirection}, ${gradientColor1}, ${gradientColor2})`;
             this.preview.shapeElement.style.backgroundColor = 'transparent';
           } else {
             this.preview.shapeElement.style.backgroundColor = shapeColor;
             this.preview.shapeElement.style.background = shapeColor;
           }
           
           // Update size based on shape type
           if (shapeType.includes('left') || shapeType.includes('right')) {
             this.preview.shapeElement.style.width = `${shapeSize}px`;
             this.preview.shapeElement.style.height = '100%';
           } else if (shapeType.includes('top') || shapeType.includes('bottom')) {
             this.preview.shapeElement.style.width = '100%';
             this.preview.shapeElement.style.height = `${shapeSize}px`;
           } else if (shapeType.includes('corner')) {
             this.preview.shapeElement.style.width = `${shapeSize}px`;
             this.preview.shapeElement.style.height = `${shapeSize}px`;
           } else if (shapeType.includes('center')) {
             this.preview.shapeElement.style.width = `${shapeSize}px`;
             this.preview.shapeElement.style.height = `${shapeSize}px`;
           } else if (shapeType.includes('diagonal')) {
             this.preview.shapeElement.style.width = '100%';
             this.preview.shapeElement.style.height = '100%';
           } else if (shapeType.includes('circle')) {
             this.preview.shapeElement.style.width = `${shapeSize}px`;
             this.preview.shapeElement.style.height = `${shapeSize}px`;
           } else if (shapeType.includes('oval')) {
             this.preview.shapeElement.style.width = `${shapeSize * 2}px`;
             this.preview.shapeElement.style.height = `${shapeSize}px`;
           } else if (shapeType.includes('triangle')) {
             this.preview.shapeElement.style.width = `${shapeSize}px`;
             this.preview.shapeElement.style.height = `${shapeSize * 1.73}px`; // Triangle height
           } else if (shapeType.includes('diamond')) {
             this.preview.shapeElement.style.width = `${shapeSize}px`;
             this.preview.shapeElement.style.height = `${shapeSize}px`;
           } else if (shapeType.includes('hexagon')) {
             this.preview.shapeElement.style.width = `${shapeSize}px`;
             this.preview.shapeElement.style.height = `${shapeSize}px`;
           }
           
           // Apply position adjustments
           if (shapePosition === 'inset') {
             this.preview.shapeElement.style.margin = '10px';
           } else if (shapePosition === 'outset') {
             this.preview.shapeElement.style.margin = '-10px';
           } else {
             this.preview.shapeElement.style.margin = '0';
           }
         } else {
           // Hide shape element
           this.preview.shapeElement.style.display = 'none';
         }
       }
       
       toggleShapeGradientControls() {
         const shapeGradientControls = document.getElementById('shapeGradientControls');
         if (this.inputs.shapeGradientEnabled && this.inputs.shapeGradientEnabled.checked) {
           shapeGradientControls.style.display = 'block';
         } else {
           shapeGradientControls.style.display = 'none';
         }
         this.updateShape();
       }
       
       toggleShapeImageControls() {
         const shapeImageControls = document.getElementById('shapeImageControls');
         if (this.inputs.shapeImageEnabled && this.inputs.shapeImageEnabled.checked) {
           shapeImageControls.style.display = 'block';
         } else {
           shapeImageControls.style.display = 'none';
         }
       }
       
       handleShapeImageUpload(event) {
         const file = event.target.files[0];
         if (file) {
           const reader = new FileReader();
           reader.onload = (e) => {
             this.preview.shapeElement.style.backgroundImage = `url(${e.target.result})`;
             this.preview.shapeElement.style.backgroundSize = 'cover';
             this.preview.shapeElement.style.backgroundPosition = 'center';
             this.showMessage('✅ Shape image uploaded successfully!', 'success');
           };
           reader.onerror = () => {
             this.showMessage('❌ Error reading shape image file', 'error');
           };
           reader.readAsDataURL(file);
         }
       }
       
       removeShapeImage() {
         this.preview.shapeElement.style.backgroundImage = 'none';
         this.inputs.shapeImageUpload.value = '';
         this.showMessage('🗑️ Shape image removed', 'success');
       }

             updateBanner() {
         try {
           // Get input values with null checks
           const title = this.inputs.title && this.inputs.title.value ? this.inputs.title.value : '';
           const subtitle2 = this.inputs.subtitle2 && this.inputs.subtitle2.value ? this.inputs.subtitle2.value : '';
           const subtitle3 = this.inputs.subtitle3 && this.inputs.subtitle3.value ? this.inputs.subtitle3.value : '';
           

           const titleSize = this.inputs.titleSize && this.inputs.titleSize.value ? this.inputs.titleSize.value : 48;
           const subtitleSize = this.inputs.subtitleSize && this.inputs.subtitleSize.value ? this.inputs.subtitleSize.value : 24;
           const bannerWidth = this.inputs.bannerWidth && this.inputs.bannerWidth.value ? this.inputs.bannerWidth.value : 1200;
           const bannerHeight = this.inputs.bannerHeight && this.inputs.bannerHeight.value ? this.inputs.bannerHeight.value : 200;
           const previewScale = this.inputs.previewScale && this.inputs.previewScale.value ? this.inputs.previewScale.value : 100;
           const font = this.inputs.fontChoice && this.inputs.fontChoice.value ? this.inputs.fontChoice.value : 'Montserrat, Arial, sans-serif';
           const textAlign = this.inputs.textAlign && this.inputs.textAlign.value ? this.inputs.textAlign.value : 'left';
           const titleColor = this.inputs.titleColor && this.inputs.titleColor.value ? this.inputs.titleColor.value : '#ffffff';
           const subtitleColor = this.inputs.subtitleColor && this.inputs.subtitleColor.value ? this.inputs.subtitleColor.value : '#ffffff';
           const subtitle3Color = this.inputs.subtitle3Color && this.inputs.subtitle3Color.value ? this.inputs.subtitle3Color.value : '#ffffff';
           const sinclairColor = this.inputs.sinclairColor && this.inputs.sinclairColor.value ? this.inputs.sinclairColor.value : '';
           const customColor = this.inputs.customBgColor && this.inputs.customBgColor.value ? this.inputs.customBgColor.value : '#ffffff';

                     // Get background color (handles gradients)
          const bgColor = this.getBackgroundColor();

          // Update banner dimensions
          const scaledWidth = (bannerWidth * previewScale) / 100;
          const scaledHeight = (bannerHeight * previewScale) / 100;
          this.preview.banner.style.maxWidth = `${scaledWidth}px`;
          this.preview.banner.style.width = `${scaledWidth}px`;
          this.preview.banner.style.height = `${scaledHeight}px`;
          
          // Scale padding based on preview scale
          const basePadding = 16; // Base padding in pixels
          const scaledPadding = (basePadding * previewScale) / 100;
          this.preview.banner.style.padding = `${scaledPadding}px`;
          
          // Update logo size using the dedicated function
          this.updateLogoSize();

          // Update banner background (handles both solid colors and gradients)
          console.log('Applying background color:', bgColor);
          if (bgColor.includes('linear-gradient')) {
            this.preview.banner.style.background = bgColor;
            this.preview.banner.style.backgroundColor = 'transparent';
            console.log('Applied gradient background');
          } else {
            this.preview.banner.style.backgroundColor = bgColor.trim();
            this.preview.banner.style.background = 'none';
            console.log('Applied solid background color:', bgColor.trim());
          }
          
          // Force the background to be visible
          this.preview.banner.style.setProperty('background-color', bgColor.trim(), 'important');
          if (bgColor.includes('linear-gradient')) {
            this.preview.banner.style.setProperty('background', bgColor, 'important');
          }
          
          // Add a visual indicator of the current background color
          console.log('Current banner background:', this.preview.banner.style.backgroundColor);
          console.log('Current banner background (computed):', getComputedStyle(this.preview.banner).backgroundColor);
          
          // Update background image styling if image exists
          if (this.preview.bgImage.style.display !== 'none' && this.preview.bgImage.src) {
            const bgImageFit = this.inputs.bgImageFit ? this.inputs.bgImageFit.value : 'cover';
            const bgImagePosition = this.inputs.bgImagePosition ? this.inputs.bgImagePosition.value : 'center';
            const bgImageXOffset = this.inputs.bgImageXOffset ? this.inputs.bgImageXOffset.value : '0';
            const bgImageYOffset = this.inputs.bgImageYOffset ? this.inputs.bgImageYOffset.value : '0';
            const bgImageScale = this.inputs.bgImageScale ? this.inputs.bgImageScale.value : '100';
            const bgImageOpacity = this.inputs.bgImageOpacity ? this.inputs.bgImageOpacity.value : '100';
            
            // Calculate position with offset
            const basePosition = bgImagePosition;
            const xOffset = parseInt(bgImageXOffset);
            const yOffset = parseInt(bgImageYOffset);
            
            // Create custom position string with offset
            let customPosition = basePosition;
            if (xOffset !== 0 || yOffset !== 0) {
              // Convert position to percentage and add offset
              let xPercent = 50; // default center
              let yPercent = 50; // default center
              
              // Parse base position
              if (basePosition.includes('left')) xPercent = 0;
              else if (basePosition.includes('right')) xPercent = 100;
              if (basePosition.includes('top')) yPercent = 0;
              else if (basePosition.includes('bottom')) yPercent = 100;
              
              // Add offset (convert -50 to 50 range to percentage)
              xPercent = Math.max(0, Math.min(100, xPercent + (xOffset + 50)));
              yPercent = Math.max(0, Math.min(100, yPercent + (yOffset + 50)));
              
              customPosition = `${xPercent}% ${yPercent}%`;
            }
            
            // For "fill" option, don't use scale transform, let object-fit handle it
            if (bgImageFit === 'fill') {
              this.preview.bgImage.style.setProperty('object-fit', 'fill', 'important');
              this.preview.bgImage.style.setProperty('object-position', customPosition, 'important');
              this.preview.bgImage.style.setProperty('transform', 'none', 'important');
              this.preview.bgImage.style.setProperty('opacity', `${bgImageOpacity / 100}`, 'important');
            } else {
              // For other fit options, use scale transform but contain it
              this.preview.bgImage.style.setProperty('object-fit', bgImageFit, 'important');
              this.preview.bgImage.style.setProperty('object-position', customPosition, 'important');
              
              // Limit scale to prevent overflow - max scale based on container size
              const maxScale = Math.min(bgImageScale / 100, 2.0); // Cap at 200%
              this.preview.bgImage.style.setProperty('transform', `scale(${maxScale})`, 'important');
              this.preview.bgImage.style.setProperty('opacity', `${bgImageOpacity / 100}`, 'important');
            }
            
            this.preview.bgImage.style.setProperty('transform-origin', 'center center', 'important');
            this.preview.bgImage.style.setProperty('overflow', 'hidden', 'important');
          }

                     // Update text content
           this.preview.title.innerText = title;
           this.preview.subtitle2.innerText = subtitle2;
           this.preview.subtitle3.innerText = subtitle3;

                     // Update text styling with preview scale
           const scaledTitleSize = Math.max((titleSize * previewScale) / 100, 12); // Minimum 12px for better visibility
           const scaledSubtitleSize = Math.max((subtitleSize * previewScale) / 100, 10); // Minimum 10px for better visibility
           
           // Apply font sizes with !important to ensure they override any CSS
           this.preview.title.style.setProperty('font-size', `${scaledTitleSize}px`, 'important');
           this.preview.subtitle2.style.setProperty('font-size', `${scaledSubtitleSize}px`, 'important');
           this.preview.subtitle3.style.setProperty('font-size', `${scaledSubtitleSize}px`, 'important');
           


                     // Update font family
           const fontFamily = font;
           this.preview.title.style.fontFamily = fontFamily;
           this.preview.subtitle2.style.fontFamily = fontFamily;
           this.preview.subtitle3.style.fontFamily = fontFamily;

                     // Update text colors with full opacity and ensure proper contrast
           const ensureBrightColor = (color) => {
             // If color is white or very light, ensure it's pure white
             if (color.toLowerCase() === '#ffffff' || color.toLowerCase() === 'white') {
               return '#ffffff';
             }
             return color;
           };
           
           this.preview.title.style.setProperty('color', ensureBrightColor(titleColor), 'important');
           this.preview.subtitle2.style.setProperty('color', ensureBrightColor(subtitleColor), 'important');
           this.preview.subtitle3.style.setProperty('color', ensureBrightColor(subtitle3Color), 'important');
           
           // Ensure full opacity for all text elements
           this.preview.title.style.setProperty('opacity', '1', 'important');
           this.preview.subtitle2.style.setProperty('opacity', '1', 'important');
           this.preview.subtitle3.style.setProperty('opacity', '1', 'important');

          // Update text alignment
          this.preview.textContainer.style.textAlign = textAlign;
          
          // Handle logo/icon display
          const logoType = this.inputs.logoType ? this.inputs.logoType.value : 'upload';
          const hasLogoImage = this.preview.logoImage && this.preview.logoImage.style.display !== 'none' && this.preview.logoImage.src;
          
          if (logoType === 'icon') {
            // Show icon, hide logo image
            this.preview.logoImage.style.display = 'none';
            this.preview.logoIcon.style.display = 'block';
            
            // Set icon content and color
            const iconEmoji = this.inputs.iconEmoji ? this.inputs.iconEmoji.value : '🎓';
            const iconColor = this.inputs.iconColor ? this.inputs.iconColor.value : '#ffffff';
            
            this.preview.logoIcon.textContent = iconEmoji;
            this.preview.logoIcon.style.color = iconColor;
          } else {
            // Show logo image, hide icon
            this.preview.logoIcon.style.display = 'none';
            if (hasLogoImage) {
              this.preview.logoImage.style.display = 'block';
            }
          }
          
          // Scale text container padding
          const baseTextPadding = 16; // Base text container padding
          const scaledTextPadding = (baseTextPadding * previewScale) / 100;
          this.preview.textContainer.style.paddingRight = `${scaledTextPadding}px`;

        } catch (error) {
          console.error('Error updating banner:', error);
          this.showMessage('❌ Error updating banner preview', 'error');
        }
      }

                     async downloadBanner() {
          try {
            console.log('Starting downloadBanner...');
            this.showLoadingState(true);
            
                        // Use Canvas API for everything (perfect colors and positioning)
            console.log('Using Canvas API for all exports');
            
            const exportDims = this.getExportDimensions();
            const originalWidth = exportDims.width;
            const originalHeight = exportDims.height;
            const quality = this.inputs.exportQuality && this.inputs.exportQuality.value ? parseFloat(this.inputs.exportQuality.value) : 0.8;
            
            // For PNG, quality affects resolution scaling
            const scale = quality === 1.0 ? 4 : quality === 0.9 ? 3 : quality === 0.8 ? 2 : 1.5;
            const scaledWidth = exportDims.width * scale;
            const scaledHeight = exportDims.height * scale;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = scaledWidth;
            canvas.height = scaledHeight;
            
            // Scale the context for higher resolution
            ctx.scale(scale, scale);
            
            // Draw background (solid color, gradient, or image)
            console.log('Checking background type...');
            const hasBgImage = this.preview.bgImage && this.preview.bgImage.style.display !== 'none' && this.preview.bgImage.src;
            
            if (hasBgImage) {
              // Handle background image
              const bgImg = new Image();
              bgImg.crossOrigin = 'anonymous';
              
              bgImg.onload = () => {
                // Get the actual CSS properties from the preview
                const bgImageStyle = getComputedStyle(this.preview.bgImage);
                const objectFit = bgImageStyle.objectFit || 'cover';
                const objectPosition = bgImageStyle.objectPosition || 'center';
                
                console.log('Background image properties:', { objectFit, objectPosition });
                
                // Calculate how to draw the image based on object-fit and object-position
                let drawWidth, drawHeight, drawX, drawY;
                
                // Parse object-position to get x and y percentages
                let xPercent = 50, yPercent = 50; // Default center
                if (objectPosition) {
                  const positionParts = objectPosition.split(' ');
                  if (positionParts.length >= 2) {
                    xPercent = parseFloat(positionParts[0]) || 50;
                    yPercent = parseFloat(positionParts[1]) || 50;
                  } else if (positionParts.length === 1) {
                    // Single value applies to both x and y
                    const value = parseFloat(positionParts[0]) || 50;
                    xPercent = value;
                    yPercent = value;
                  }
                }
                
                if (objectFit === 'cover') {
                  // Calculate aspect ratios
                  const canvasAspect = originalWidth / originalHeight;
                  const imgAspect = bgImg.width / bgImg.height;
                  
                  if (imgAspect > canvasAspect) {
                    // Image is wider - fit to height, crop width
                    drawHeight = originalHeight;
                    drawWidth = originalHeight * imgAspect;
                    drawX = (originalWidth - drawWidth) * (xPercent / 100);
                    drawY = 0;
                  } else {
                    // Image is taller - fit to width, crop height
                    drawWidth = originalWidth;
                    drawHeight = originalWidth / imgAspect;
                    drawX = 0;
                    drawY = (originalHeight - drawHeight) * (yPercent / 100);
                  }
                } else if (objectFit === 'contain') {
                  // Fit entire image within canvas
                  const canvasAspect = originalWidth / originalHeight;
                  const imgAspect = bgImg.width / bgImg.height;
                  
                  if (imgAspect > canvasAspect) {
                    // Image is wider - fit to width
                    drawWidth = originalWidth;
                    drawHeight = originalWidth / imgAspect;
                    drawX = 0;
                    drawY = (originalHeight - drawHeight) * (yPercent / 100);
                  } else {
                    // Image is taller - fit to height
                    drawHeight = originalHeight;
                    drawWidth = originalHeight * imgAspect;
                    drawX = (originalWidth - drawWidth) * (xPercent / 100);
                    drawY = 0;
                  }
                } else if (objectFit === 'fill') {
                  // Stretch to fill
                  drawWidth = originalWidth;
                  drawHeight = originalHeight;
                  drawX = 0;
                  drawY = 0;
                } else {
                  // Default to cover behavior
                  const canvasAspect = originalWidth / originalHeight;
                  const imgAspect = bgImg.width / bgImg.height;
                  
                  if (imgAspect > canvasAspect) {
                    drawHeight = originalHeight;
                    drawWidth = originalHeight * imgAspect;
                    drawX = (originalWidth - drawWidth) * (xPercent / 100);
                    drawY = 0;
                  } else {
                    drawWidth = originalWidth;
                    drawHeight = originalWidth / imgAspect;
                    drawX = 0;
                    drawY = (originalHeight - drawHeight) * (yPercent / 100);
                  }
                }
                
                // Apply opacity
                const bgImageOpacity = this.inputs.bgImageOpacity ? this.inputs.bgImageOpacity.value : 100;
                ctx.globalAlpha = bgImageOpacity / 100;
                
                // Draw background image with proper fitting and positioning
                ctx.drawImage(bgImg, drawX, drawY, drawWidth, drawHeight);
                
                // Reset alpha for other elements
                ctx.globalAlpha = 1.0;
                
                this.drawShapesAndText(ctx, canvas, originalWidth, originalHeight);
                this.drawLogoAndDownload(ctx, canvas, originalWidth, originalHeight);
              };
              
              bgImg.onerror = () => {
                console.error('Failed to load background image');
                this.showMessage('❌ Error loading background image', 'error');
                this.showLoadingState(false);
              };
              
              bgImg.src = this.preview.bgImage.src;
              
            } else {
              // Handle solid color or gradient background
              const bgColor = this.getBackgroundColor();
              
              console.log('Background color:', bgColor);
              if (bgColor.includes('linear-gradient')) {
                console.log('Gradient detected, parsing:', bgColor);
                
                // Parse gradient string like "linear-gradient(135deg, #AC1A2F 0%, #8b0000 50%, #660000 100%)"
                const match = bgColor.match(/linear-gradient\(([^)]+)\)/);
                if (match) {
                  const content = match[1];
                  console.log('Gradient content:', content);
                  
                  // Split by comma to get direction and color stops
                  const parts = content.split(',').map(part => part.trim());
                  console.log('Parts:', parts);
                  
                  if (parts.length >= 3) {
                    const direction = parts[0];
                    const colorStops = parts.slice(1);
                    
                    console.log('Direction:', direction);
                    console.log('Color stops:', colorStops);
                    
                    // Parse colors and positions
                    const colors = [];
                    const positions = [];
                    
                    colorStops.forEach((stop, index) => {
                      // Extract color (hex format)
                      const colorMatch = stop.match(/(#[0-9a-fA-F]{3,6})/);
                      if (colorMatch) {
                        colors.push(colorMatch[1]);
                        
                        // Extract position (percentage)
                        const positionMatch = stop.match(/(\d+)%/);
                        if (positionMatch) {
                          positions.push(parseFloat(positionMatch[1]) / 100);
                        } else {
                          // Default positions
                          if (index === 0) positions.push(0);
                          else if (index === 1) positions.push(0.5);
                          else if (index === 2) positions.push(1);
                        }
                      }
                    });
                    
                    console.log('Parsed colors:', colors);
                    console.log('Parsed positions:', positions);
                    
                    if (colors.length >= 2) {
                      // Create gradient
                      let gradient;
                      if (direction.includes('135deg')) {
                        gradient = ctx.createLinearGradient(originalWidth, 0, 0, originalHeight);
                      } else if (direction.includes('45deg')) {
                        gradient = ctx.createLinearGradient(0, 0, originalWidth, originalHeight);
                      } else if (direction.includes('90deg')) {
                        gradient = ctx.createLinearGradient(0, 0, originalWidth, 0);
                      } else if (direction.includes('180deg')) {
                        gradient = ctx.createLinearGradient(0, 0, 0, originalHeight);
                      } else {
                        // Default to 135deg
                        gradient = ctx.createLinearGradient(originalWidth, 0, 0, originalHeight);
                      }
                      
                      // Add color stops
                      colors.forEach((color, index) => {
                        const position = positions[index] || (index / (colors.length - 1));
                        gradient.addColorStop(position, color);
                      });
                      
                      ctx.fillStyle = gradient;
                      ctx.fillRect(0, 0, canvas.width, canvas.height);
                    } else {
                      console.log('Not enough colors, using fallback');
                      ctx.fillStyle = '#AC1A2F';
                      ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                  } else {
                    console.log('Not enough parts, using fallback');
                    ctx.fillStyle = '#AC1A2F';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                  }
                } else {
                  console.log('No gradient match, using fallback');
                  ctx.fillStyle = '#AC1A2F';
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
              } else {
                // Draw solid color background
                ctx.fillStyle = bgColor.trim();
                ctx.fillRect(0, 0, canvas.width, canvas.height);
              }
              
              this.drawShapesAndText(ctx, canvas, originalWidth, originalHeight);
              this.drawLogoAndDownload(ctx, canvas, originalWidth, originalHeight);
            }
            
          } catch (error) {
            console.error('Error downloading banner:', error);
            this.showMessage('❌ Error downloading banner', 'error');
            this.showLoadingState(false);
          }
        }
        
        drawGradientBackground(ctx, canvas, gradientString, exportDims) {
          console.log('Gradient function called with:', gradientString);
          
          // Simple fallback - just draw a solid color for now
          ctx.fillStyle = '#AC1A2F';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        drawShapesAndText(ctx, canvas, originalWidth, originalHeight) {
          // Draw shapes
          const shapeType = this.inputs.shapeType && this.inputs.shapeType.value ? this.inputs.shapeType.value : '';
          const hasShape = shapeType && shapeType !== '';
          
          if (hasShape) {
            const shapeColor = this.inputs.shapeColor && this.inputs.shapeColor.value ? this.inputs.shapeColor.value : '#ffffff';
            const shapeSize = this.inputs.shapeSize && this.inputs.shapeSize.value ? parseInt(this.inputs.shapeSize.value) : 20;
            const shapeOpacity = this.inputs.shapeOpacity && this.inputs.shapeOpacity.value ? parseInt(this.inputs.shapeOpacity.value) : 100;
            
            ctx.globalAlpha = shapeOpacity / 100;
            
            // Handle shape gradient
            const useShapeGradient = this.inputs.shapeGradientEnabled && this.inputs.shapeGradientEnabled.checked;
            let gradientColor1, gradientColor2, gradientDirection;
            
            if (useShapeGradient) {
              console.log('Shape gradient enabled');
              gradientColor1 = this.inputs.shapeGradientColor1 && this.inputs.shapeGradientColor1.value ? this.inputs.shapeGradientColor1.value : '#ffffff';
              gradientColor2 = this.inputs.shapeGradientColor2 && this.inputs.shapeGradientColor2.value ? this.inputs.shapeGradientColor2.value : '#cccccc';
              gradientDirection = this.inputs.shapeGradientDirection && this.inputs.shapeGradientDirection.value ? this.inputs.shapeGradientDirection.value : 'to right';
              
              console.log('Shape gradient colors:', gradientColor1, gradientColor2);
              console.log('Shape gradient direction:', gradientDirection);
            } else {
              ctx.fillStyle = shapeColor;
            }
            
            // Helper function to create gradient for shapes
            const createShapeGradient = (x, y, width, height) => {
              if (!useShapeGradient) return;
              
              let shapeGradient;
              if (gradientDirection.includes('to right') || gradientDirection.includes('90deg')) {
                shapeGradient = ctx.createLinearGradient(x, y, x + width, y);
              } else if (gradientDirection.includes('to bottom') || gradientDirection.includes('180deg')) {
                shapeGradient = ctx.createLinearGradient(x, y, x, y + height);
              } else if (gradientDirection.includes('45deg')) {
                shapeGradient = ctx.createLinearGradient(x, y, x + width, y + height);
              } else if (gradientDirection.includes('135deg')) {
                shapeGradient = ctx.createLinearGradient(x + width, y, x, y + height);
              } else {
                // Default to horizontal
                shapeGradient = ctx.createLinearGradient(x, y, x + width, y);
              }
              
              const cleanColor1 = gradientColor1.replace(/['"]/g, '').trim();
              const cleanColor2 = gradientColor2.replace(/['"]/g, '').trim();
              shapeGradient.addColorStop(0, cleanColor1);
              shapeGradient.addColorStop(1, cleanColor2);
              ctx.fillStyle = shapeGradient;
            };
            
                        // Use original dimensions since context is scaled (already passed as parameters)
            
            if (shapeType.includes('left')) {
              createShapeGradient(0, 0, shapeSize, originalHeight);
              ctx.fillRect(0, 0, shapeSize, originalHeight);
            } else if (shapeType.includes('right')) {
              createShapeGradient(originalWidth - shapeSize, 0, shapeSize, originalHeight);
              ctx.fillRect(originalWidth - shapeSize, 0, shapeSize, originalHeight);
            } else if (shapeType.includes('top')) {
              createShapeGradient(0, 0, originalWidth, shapeSize);
              ctx.fillRect(0, 0, originalWidth, shapeSize);
            } else if (shapeType.includes('bottom')) {
              createShapeGradient(0, originalHeight - shapeSize, originalWidth, shapeSize);
              ctx.fillRect(0, originalHeight - shapeSize, originalWidth, shapeSize);
            } else if (shapeType.includes('corner-tl')) {
              createShapeGradient(0, 0, shapeSize, shapeSize);
              ctx.fillRect(0, 0, shapeSize, shapeSize);
            } else if (shapeType.includes('corner-tr')) {
              createShapeGradient(originalWidth - shapeSize, 0, shapeSize, shapeSize);
              ctx.fillRect(originalWidth - shapeSize, 0, shapeSize, shapeSize);
            } else if (shapeType.includes('corner-bl')) {
              createShapeGradient(0, originalHeight - shapeSize, shapeSize, shapeSize);
              ctx.fillRect(0, originalHeight - shapeSize, shapeSize, shapeSize);
            } else if (shapeType.includes('corner-br')) {
              createShapeGradient(originalWidth - shapeSize, originalHeight - shapeSize, shapeSize, shapeSize);
              ctx.fillRect(originalWidth - shapeSize, originalHeight - shapeSize, shapeSize, shapeSize);
            } else if (shapeType.includes('center')) {
              const centerX = (originalWidth - shapeSize) / 2;
              const centerY = (originalHeight - shapeSize) / 2;
              createShapeGradient(centerX, centerY, shapeSize, shapeSize);
              ctx.fillRect(centerX, centerY, shapeSize, shapeSize);
            } else if (shapeType.includes('diagonal')) {
              // Draw diagonal bar
              createShapeGradient(-originalWidth / 2, -shapeSize / 2, originalWidth, shapeSize);
              ctx.save();
              ctx.translate(originalWidth / 2, originalHeight / 2);
              ctx.rotate(Math.PI / 4);
              ctx.fillRect(-originalWidth / 2, -shapeSize / 2, originalWidth, shapeSize);
              ctx.restore();
            } else if (shapeType.includes('circle')) {
              const centerX = originalWidth / 2;
              const centerY = originalHeight / 2;
              createShapeGradient(centerX - shapeSize / 2, centerY - shapeSize / 2, shapeSize, shapeSize);
              ctx.beginPath();
              ctx.arc(centerX, centerY, shapeSize / 2, 0, 2 * Math.PI);
              ctx.fill();
            } else if (shapeType.includes('oval')) {
              const centerX = originalWidth / 2;
              const centerY = originalHeight / 2;
              createShapeGradient(centerX - shapeSize, centerY - shapeSize / 2, shapeSize * 2, shapeSize);
              ctx.beginPath();
              ctx.ellipse(centerX, centerY, shapeSize, shapeSize / 2, 0, 0, 2 * Math.PI);
              ctx.fill();
            } else if (shapeType.includes('triangle')) {
              const centerX = originalWidth / 2;
              const centerY = originalHeight / 2;
              const height = shapeSize * 1.73;
              createShapeGradient(centerX - shapeSize / 2, centerY - height / 2, shapeSize, height);
              ctx.beginPath();
              ctx.moveTo(centerX, centerY - height / 2);
              ctx.lineTo(centerX - shapeSize / 2, centerY + height / 2);
              ctx.lineTo(centerX + shapeSize / 2, centerY + height / 2);
              ctx.closePath();
              ctx.fill();
            } else if (shapeType.includes('diamond')) {
              const centerX = originalWidth / 2;
              const centerY = originalHeight / 2;
              createShapeGradient(centerX - shapeSize / 2, centerY - shapeSize / 2, shapeSize, shapeSize);
              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.rotate(Math.PI / 4);
              ctx.fillRect(-shapeSize / 2, -shapeSize / 2, shapeSize, shapeSize);
              ctx.restore();
            } else if (shapeType.includes('hexagon')) {
              const centerX = originalWidth / 2;
              const centerY = originalHeight / 2;
              const radius = shapeSize / 2;
              createShapeGradient(centerX - radius, centerY - radius, shapeSize, shapeSize);
              ctx.beginPath();
              for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                if (i === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              }
              ctx.closePath();
              ctx.fill();
            }
            
            ctx.globalAlpha = 1.0; // Reset opacity
          }
          
          // Draw text
          const title = this.inputs.title && this.inputs.title.value ? this.inputs.title.value : '';
          const subtitle2 = this.inputs.subtitle2 && this.inputs.subtitle2.value ? this.inputs.subtitle2.value : '';
          const subtitle3 = this.inputs.subtitle3 && this.inputs.subtitle3.value ? this.inputs.subtitle3.value : '';
          
          const titleSize = this.inputs.titleSize && this.inputs.titleSize.value ? parseInt(this.inputs.titleSize.value) : 48;
          const subtitleSize = this.inputs.subtitleSize && this.inputs.subtitleSize.value ? parseInt(this.inputs.subtitleSize.value) : 24;
          const font = this.inputs.fontChoice && this.inputs.fontChoice.value ? this.inputs.fontChoice.value : 'Arial, sans-serif';
          
          // Check if logo is present to adjust text width
          const hasLogo = this.preview.logoImage && this.preview.logoImage.style.display !== 'none' && this.preview.logoImage.src;
          const logoSize = this.inputs.logoSize && this.inputs.logoSize.value ? parseInt(this.inputs.logoSize.value) : 120;
          const textMaxWidth = hasLogo ? originalWidth - logoSize - 80 : originalWidth - 40; // Leave space for logo
          
          // Get text alignment setting
          const textAlign = this.inputs.textAlign && this.inputs.textAlign.value ? this.inputs.textAlign.value : 'left';
          ctx.textAlign = textAlign;
          
          // Calculate padding (same as live preview)
          let basePadding = 16; // var(--spacing-md)
          
          // Reduce padding for course card dimensions
          if (originalWidth === 262 && originalHeight === 147) {
            basePadding = 8; // Smaller padding for course card
          }
          
          const padding = basePadding;
          
          // Calculate x position based on alignment and padding
          let xPos;
          if (textAlign === 'center') {
            xPos = originalWidth / 2;
          } else if (textAlign === 'right') {
            xPos = originalWidth - padding;
          } else {
            xPos = padding; // left alignment
          }
          
          // Account for text container padding (same as live preview)
          const textContainerPadding = padding;
          if (textAlign === 'left') {
            xPos += textContainerPadding; // Add padding for left alignment
          }
          
          // Calculate total text height for vertical centering
          ctx.font = `bold ${titleSize}px ${font}`;
          const titleLines = this.wrapText(ctx, title, textMaxWidth);
          const titleHeight = titleLines.length * (titleSize + 5) - 5; // Subtract 5 for last line
          
          ctx.font = `${subtitleSize}px ${font}`;
          const subtitle2Lines = this.wrapText(ctx, subtitle2, textMaxWidth);
          const subtitle2Height = subtitle2Lines.length * (subtitleSize + 3) - 3; // Reduced spacing for PNG
          
          const subtitle3Lines = this.wrapText(ctx, subtitle3, textMaxWidth);
          const subtitle3Height = subtitle3Lines.length * (subtitleSize + 3) - 3; // Reduced spacing for PNG
          
          const totalTextHeight = titleHeight + subtitle2Height + subtitle3Height;
          
          // Account for flexbox centering (same as live preview)
          // The live preview uses flexbox with align-items: center, so we need to match that
          const startY = (originalHeight - totalTextHeight) / 2;
          
          // Add a small offset to match the live preview exactly
          let verticalOffset = 50; // Move text down by 50px to match live preview
          
          // Adjust for course card dimensions (262x147)
          if (originalWidth === 262 && originalHeight === 147) {
            verticalOffset = 20; // Smaller offset for course card
          }
          
          // Draw title
          ctx.font = `bold ${titleSize}px ${font}`;
          ctx.fillStyle = this.inputs.titleColor && this.inputs.titleColor.value ? this.inputs.titleColor.value : '#ffffff';
          
          let yOffset = startY + verticalOffset;
          titleLines.forEach(line => {
            ctx.fillText(line, xPos, yOffset);
            yOffset += titleSize + 5;
          });
          
          // Draw subtitle2 (reduced spacing for PNG)
          ctx.font = `${subtitleSize}px ${font}`;
          ctx.fillStyle = this.inputs.subtitleColor && this.inputs.subtitleColor.value ? this.inputs.subtitleColor.value : '#ffffff';
          
          // Move subtitle up by 15px (adjust for course card)
          if (originalWidth === 262 && originalHeight === 147) {
            yOffset -= 8; // Smaller adjustment for course card
          } else {
            yOffset -= 15; // Normal adjustment for other sizes
          }
          
          subtitle2Lines.forEach(line => {
            ctx.fillText(line, xPos, yOffset);
            yOffset += subtitleSize + 3; // Reduced spacing for PNG
          });
          
          // Draw subtitle3 (reduced spacing for PNG)
          subtitle3Lines.forEach(line => {
            ctx.fillText(line, xPos, yOffset);
            yOffset += subtitleSize + 3; // Reduced spacing for PNG
          });
        }
        
        drawLogoAndDownload(ctx, canvas, originalWidth, originalHeight) {
          // Add logo if present
          const hasLogo = this.preview.logoImage && this.preview.logoImage.style.display !== 'none' && this.preview.logoImage.src;
          if (hasLogo) {
            const logoImg = new Image();
            logoImg.crossOrigin = 'anonymous';
            
            logoImg.onload = () => {
              const logoSize = this.inputs.logoSize && this.inputs.logoSize.value ? parseInt(this.inputs.logoSize.value) : 120;
              const maxLogoHeight = originalHeight - 40;
              const finalLogoSize = Math.min(logoSize, maxLogoHeight);
              
              // Give more space for logo - move it further right and make it smaller if needed
              let logoX = originalWidth - finalLogoSize - 40; // More padding
              
              // Move logo further right for course card dimensions
              if (originalWidth === 262 && originalHeight === 147) {
                logoX = originalWidth - finalLogoSize - 20; // Closer to right edge for course card
              }
              
              const logoY = (originalHeight - finalLogoSize) / 2;
              
              // Scale logo to fit better
              const aspectRatio = logoImg.width / logoImg.height;
              let drawWidth = finalLogoSize;
              let drawHeight = finalLogoSize;
              
              // Maintain aspect ratio
              if (aspectRatio > 1) {
                // Logo is wider than tall
                drawHeight = finalLogoSize / aspectRatio;
                drawWidth = finalLogoSize;
              } else {
                // Logo is taller than wide
                drawWidth = finalLogoSize * aspectRatio;
                drawHeight = finalLogoSize;
              }
              
              ctx.drawImage(logoImg, logoX, logoY, drawWidth, drawHeight);
              
              // Download
              const link = document.createElement('a');
              const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
              link.download = `${fileName}.png`;
              link.href = canvas.toDataURL('image/png', 1.0);
              link.click();
              
              this.showMessage('✅ Banner downloaded successfully with logo!', 'success');
              this.showLoadingState(false);
            };
            
            logoImg.onerror = () => {
              // Download without logo
              const link = document.createElement('a');
              const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
              link.download = `${fileName}.png`;
              link.href = canvas.toDataURL('image/png', 1.0);
              link.click();
              
              this.showMessage('✅ Banner downloaded successfully!', 'success');
              this.showLoadingState(false);
            };
            
            logoImg.src = this.preview.logoImage.src;
          } else {
            // Download without logo
            const link = document.createElement('a');
            const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
            link.download = `${fileName}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
            
            this.showMessage('✅ Banner downloaded successfully!', 'success');
            this.showLoadingState(false);
          }
        }
        
        wrapText(ctx, text, maxWidth) {
          if (!text) return [''];
          
          const words = text.split(' ');
          const lines = [];
          let currentLine = words[0] || '';
          
          for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + ' ' + word).width;
            if (width < maxWidth) {
              currentLine += ' ' + word;
            } else {
              lines.push(currentLine);
              currentLine = word;
            }
          }
          lines.push(currentLine);
          return lines;
        }
       
               

       async exportAsPDF() {
         try {
           this.showLoadingState(true);
           
           // Get export dimensions
           const exportDims = this.getExportDimensions();
           
           const quality = this.inputs.exportQuality && this.inputs.exportQuality.value ? parseFloat(this.inputs.exportQuality.value) : 1.0;
           const scale = quality === 1.0 ? 4 : quality === 0.9 ? 3 : quality === 0.8 ? 2 : 1.5;
           
           // Create a new banner with export dimensions using createExportBanner
           const tempBanner = this.createExportBanner(exportDims);
           
           // Temporarily add to DOM for rendering
           tempBanner.style.position = 'absolute';
           tempBanner.style.left = '-9999px';
           tempBanner.style.top = '-9999px';
           document.body.appendChild(tempBanner);
           
           const canvas = await html2canvas(tempBanner, {
             width: exportDims.width,
             height: exportDims.height,
             scale: scale,
             useCORS: true,
             allowTaint: true,
             backgroundColor: null,
             imageTimeout: 0,
             logging: false,
             removeContainer: true
           });
           
           // Remove temporary banner
           document.body.removeChild(tempBanner);
           
           const imgData = canvas.toDataURL('image/png');
           const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
           const pdf = new jspdf.jsPDF({ orientation: 'landscape' });
           pdf.addImage(imgData, 'PNG', 10, 10, 270, 50);
           pdf.save(`${fileName}.pdf`);
           this.showMessage('✅ PDF exported successfully!', 'success');
         } catch (error) {
           console.error('Error exporting PDF:', error);
           this.showMessage('❌ Error exporting PDF', 'error');
         } finally {
           this.showLoadingState(false);
         }
       }

             async exportAsJPG() {
         try {
           this.showLoadingState(true);
           
           // Get export dimensions
           const exportDims = this.getExportDimensions();
           
           const quality = this.inputs.exportQuality && this.inputs.exportQuality.value ? parseFloat(this.inputs.exportQuality.value) : 1.0;
           
           // For JPG, quality affects both resolution and compression
           const scale = quality === 1.0 ? 4 : quality === 0.9 ? 3 : quality === 0.8 ? 2 : 1.5; // Much higher scaling for better quality
           const scaledWidth = exportDims.width * scale;
           const scaledHeight = exportDims.height * scale;
           
           // Create a new banner with export dimensions using createExportBanner
           const tempBanner = this.createExportBanner(exportDims);
           
           // Temporarily add to DOM for rendering
           tempBanner.style.position = 'absolute';
           tempBanner.style.left = '-9999px';
           tempBanner.style.top = '-9999px';
           document.body.appendChild(tempBanner);
           
           const canvas = await html2canvas(tempBanner, {
             width: exportDims.width,
             height: exportDims.height,
             scale: scale,
             useCORS: true,
             allowTaint: true,
             backgroundColor: null,
             imageTimeout: 0,
             logging: false,
             removeContainer: true
           });
           
           // Remove temporary banner
           document.body.removeChild(tempBanner);
           
           const link = document.createElement('a');
           const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
           link.download = `${fileName}.jpg`;
           link.href = canvas.toDataURL("image/jpeg", quality);
           link.click();
           this.showMessage('✅ JPG exported successfully!', 'success');
         } catch (error) {
           console.error('Error exporting JPG:', error);
           this.showMessage('❌ Error exporting JPG', 'error');
         } finally {
           this.showLoadingState(false);
         }
       }

       async exportAsWebP() {
         try {
           this.showLoadingState(true);
           
           // Get export dimensions
           const exportDims = this.getExportDimensions();
           
           const quality = this.inputs.exportQuality && this.inputs.exportQuality.value ? parseFloat(this.inputs.exportQuality.value) : 1.0;
           
           // For WebP, quality affects both resolution and compression
           const scale = quality === 1.0 ? 4 : quality === 0.9 ? 3 : quality === 0.8 ? 2 : 1.5; // Much higher scaling for better quality
           const scaledWidth = exportDims.width * scale;
           const scaledHeight = exportDims.height * scale;
           
           // Create a new banner with export dimensions using createExportBanner
           const tempBanner = this.createExportBanner(exportDims);
           
           // Temporarily add to DOM for rendering
           tempBanner.style.position = 'absolute';
           tempBanner.style.left = '-9999px';
           tempBanner.style.top = '-9999px';
           document.body.appendChild(tempBanner);
           
           const canvas = await html2canvas(tempBanner, {
             width: exportDims.width,
             height: exportDims.height,
             scale: scale,
             useCORS: true,
             allowTaint: true,
             backgroundColor: null,
             imageTimeout: 0,
             logging: false,
             removeContainer: true
           });
           
           // Remove temporary banner
           document.body.removeChild(tempBanner);
           
           const link = document.createElement('a');
           const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
           link.download = `${fileName}.webp`;
           link.href = canvas.toDataURL("image/webp", quality);
           link.click();
           this.showMessage('✅ WebP exported successfully!', 'success');
         } catch (error) {
           console.error('Error exporting WebP:', error);
           this.showMessage('❌ Error exporting WebP', 'error');
         } finally {
           this.showLoadingState(false);
         }
       }

       async exportAsHTML() {
         try {
           this.showLoadingState(true);
           
           // Get export dimensions
           const exportDims = this.getExportDimensions();
           
           // Get current banner settings
           const title = this.inputs.title && this.inputs.title.value ? this.inputs.title.value : '';
           const subtitle2 = this.inputs.subtitle2 && this.inputs.subtitle2.value ? this.inputs.subtitle2.value : '';
           const subtitle3 = this.inputs.subtitle3 && this.inputs.subtitle3.value ? this.inputs.subtitle3.value : '';
           const titleSize = this.inputs.titleSize && this.inputs.titleSize.value ? parseInt(this.inputs.titleSize.value) : 48;
           const subtitleSize = this.inputs.subtitleSize && this.inputs.subtitleSize.value ? parseInt(this.inputs.subtitleSize.value) : 24;
           const font = this.inputs.fontChoice && this.inputs.fontChoice.value ? this.inputs.fontChoice.value : 'Montserrat, Arial, sans-serif';
           const titleColor = this.inputs.titleColor && this.inputs.titleColor.value ? this.inputs.titleColor.value : '#ffffff';
           const subtitleColor = this.inputs.subtitleColor && this.inputs.subtitleColor.value ? this.inputs.subtitleColor.value : '#ffffff';
           const subtitle3Color = this.inputs.subtitle3Color && this.inputs.subtitle3Color.value ? this.inputs.subtitle3Color.value : '#ffffff';
           const textAlign = this.inputs.textAlign && this.inputs.textAlign.value ? this.inputs.textAlign.value : 'left';
           const logoSize = this.inputs.logoSize && this.inputs.logoSize.value ? parseInt(this.inputs.logoSize.value) : 120;
           
           // Get background color
           const bgColor = this.getBackgroundColor();
           
           // Check if logo exists
           const hasLogo = this.preview.logoImage && this.preview.logoImage.style.display !== 'none' && this.preview.logoImage.src;
           const logoType = this.inputs.logoType ? this.inputs.logoType.value : 'upload';
           const hasIcon = logoType === 'icon';
           
           // Generate HTML
                           let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Banner</title>
</head>
<body style="margin: 0; padding: 0;">
    <div style="width: ${exportDims.width}px; height: ${exportDims.height}px; ${bgColor.includes('linear-gradient') ? `background: ${bgColor};` : `background-color: ${bgColor};`} padding: 20px; position: relative; overflow: hidden;">
        <div style="width: ${hasLogo || hasIcon ? exportDims.width - logoSize - 60 : exportDims.width - 40}px; text-align: ${textAlign};">
            <h1 style="margin: 0; font-family: ${font}; font-size: ${titleSize}px; font-weight: 700; color: ${titleColor}; line-height: 1.2;">${title}</h1>
            ${subtitle2 ? `<p style="margin: 0; font-family: ${font}; font-size: ${subtitleSize}px; font-weight: 300; color: ${subtitleColor}; line-height: 1.2;">${subtitle2}</p>` : ''}
            ${subtitle3 ? `<p style="margin: 0; font-family: ${font}; font-size: ${subtitleSize}px; font-weight: 300; color: ${subtitle3Color}; line-height: 1.2;">${subtitle3}</p>` : ''}
        </div>
        ${hasLogo ? `<img src="logo.png" alt="Logo" style="position: absolute; right: 20px; top: 20px; width: ${logoSize}px; height: auto;">` : ''}
        ${hasIcon ? `<div style="position: absolute; right: 20px; top: 20px; font-size: ${logoSize}px; color: ${this.inputs.iconColor ? this.inputs.iconColor.value : '#ffffff'}; line-height: 1;">${this.inputs.iconEmoji ? this.inputs.iconEmoji.value : '🎓'}</div>` : ''}
    </div>
</body>
</html>`;
           
           // Create download link
           const link = document.createElement('a');
           const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
           link.download = `${fileName}.html`;
           link.href = 'data:text/html;charset=utf-8,' + encodeURIComponent(html);
           link.click();
           
           this.showMessage('✅ HTML exported successfully!', 'success');
         } catch (error) {
           console.error('Error exporting HTML:', error);
           this.showMessage('❌ Error exporting HTML', 'error');
         } finally {
           this.showLoadingState(false);
         }
       }

       async exportAsSVG() {
         try {
           this.showLoadingState(true);
           
           // Get export dimensions
           const exportDims = this.getExportDimensions();
           
           // Create a new banner with export dimensions using createExportBanner
           const tempBanner = this.createExportBanner(exportDims);
           
           // Temporarily add to DOM for rendering
           tempBanner.style.position = 'absolute';
           tempBanner.style.left = '-9999px';
           tempBanner.style.top = '-9999px';
           document.body.appendChild(tempBanner);
           
           const canvas = await html2canvas(tempBanner, {
             width: exportDims.width,
             height: exportDims.height,
             scale: 1
           });
           
           // Remove temporary banner
           document.body.removeChild(tempBanner);
           
           const fileName = this.inputs.exportFileName && this.inputs.exportFileName.value ? this.inputs.exportFileName.value : 'canvas-banner';
           
           // Convert canvas to SVG-like structure
           const svgData = this.canvasToSVG(canvas);
           const blob = new Blob([svgData], { type: 'image/svg+xml' });
           const url = URL.createObjectURL(blob);
           
           const link = document.createElement('a');
           link.download = `${fileName}.svg`;
           link.href = url;
           link.click();
           
           URL.revokeObjectURL(url);
           this.showMessage('✅ SVG exported successfully!', 'success');
         } catch (error) {
           console.error('Error exporting SVG:', error);
           this.showMessage('❌ Error exporting SVG', 'error');
         } finally {
           this.showLoadingState(false);
         }
       }

       async copyToClipboard() {
         try {
           this.showLoadingState(true);
           
           // Get export dimensions
           const exportDims = this.getExportDimensions();
           
           // Create a new banner with export dimensions using createExportBanner
           const tempBanner = this.createExportBanner(exportDims);
           
           // Temporarily add to DOM for rendering
           tempBanner.style.position = 'absolute';
           tempBanner.style.left = '-9999px';
           tempBanner.style.top = '-9999px';
           document.body.appendChild(tempBanner);
           
           const canvas = await html2canvas(tempBanner, {
             width: exportDims.width,
             height: exportDims.height,
             scale: 1
           });
           
           // Remove temporary banner
           document.body.removeChild(tempBanner);
           
           canvas.toBlob(async (blob) => {
             try {
               await navigator.clipboard.write([
                 new ClipboardItem({
                   'image/png': blob
                 })
               ]);
               this.showMessage('✅ Banner copied to clipboard!', 'success');
             } catch (error) {
               console.error('Error copying to clipboard:', error);
               this.showMessage('❌ Error copying to clipboard', 'error');
             } finally {
               this.showLoadingState(false);
             }
           });
         } catch (error) {
           console.error('Error copying to clipboard:', error);
           this.showMessage('❌ Error copying to clipboard', 'error');
           this.showLoadingState(false);
         }
       }

       canvasToSVG(canvas) {
         const ctx = canvas.getContext('2d');
         const width = canvas.width;
         const height = canvas.height;
         
         // Get image data
         const imageData = ctx.getImageData(0, 0, width, height);
         const data = imageData.data;
         
         // Create SVG with embedded PNG (simplified approach)
         const pngData = canvas.toDataURL('image/png');
         
         return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
           <image href="${pngData}" width="${width}" height="${height}"/>
         </svg>`;
       }

       getExportDimensions() {
         const size = this.inputs.exportSize && this.inputs.exportSize.value ? this.inputs.exportSize.value : 'original';
         const currentWidth = this.inputs.bannerWidth && this.inputs.bannerWidth.value ? parseInt(this.inputs.bannerWidth.value) : 1200;
         const currentHeight = this.inputs.bannerHeight && this.inputs.bannerHeight.value ? parseInt(this.inputs.bannerHeight.value) : 200;
         
         switch (size) {
           case 'original':
             return { width: currentWidth, height: currentHeight };
           case 'canvas-optimal':
             return { width: 1200, height: 200 };
           case 'high-res':
             return { width: 2400, height: 400 };
           case 'web-optimized':
             return { width: 800, height: 133 };
           case 'canvas-card':
             return { width: 262, height: 147 };
           default:
             return { width: currentWidth, height: currentHeight };
         }
       }

      showMessage(message, type) {
        this.messageContainer.innerHTML = `<div class="message ${type}">${message}</div>`;
        setTimeout(() => {
          this.messageContainer.innerHTML = '';
        }, 3000);
      }

             updatePreviewScale() {
         const scale = this.inputs.previewScale && this.inputs.previewScale.value ? this.inputs.previewScale.value : 100;
         if (this.scaleValue) {
           this.scaleValue.textContent = `${scale}%`;
         }
         this.updateBanner();
         
         // Add visual feedback for text scaling
         this.preview.title.style.transition = 'font-size 0.3s ease';
         this.preview.subtitle2.style.transition = 'font-size 0.3s ease';
         this.preview.subtitle3.style.transition = 'font-size 0.3s ease';
       }
       
       updateLogoSize() {
         const logoSize = this.inputs.logoSize && this.inputs.logoSize.value ? this.inputs.logoSize.value : 120;
         if (this.logoSizeValue) {
           this.logoSizeValue.textContent = `${logoSize}px`;
         }
         
         // Apply logo size with current preview scale and container constraints
         const previewScale = this.inputs.previewScale && this.inputs.previewScale.value ? this.inputs.previewScale.value : 100;
         const bannerHeight = this.inputs.bannerHeight && this.inputs.bannerHeight.value ? this.inputs.bannerHeight.value : 200;
         const scaledLogoSize = (logoSize * previewScale) / 100;
         const scaledHeight = (bannerHeight * previewScale) / 100;
         const basePadding = 16;
         const scaledPadding = (basePadding * previewScale) / 100;
         
         // Ensure logo doesn't exceed container height (accounting for padding)
         const containerHeight = scaledHeight;
         const containerPadding = scaledPadding * 2; // Top and bottom padding
         const maxLogoHeight = containerHeight - containerPadding;
         const finalLogoSize = Math.min(scaledLogoSize, maxLogoHeight);
         
         // Update logo image
         this.preview.logoImage.style.maxWidth = `${finalLogoSize}px`;
         this.preview.logoImage.style.maxHeight = `${finalLogoSize}px`;
         this.preview.logoImage.style.width = 'auto';
         this.preview.logoImage.style.height = 'auto';
         this.preview.logoImage.style.transition = 'max-width 0.3s ease, max-height 0.3s ease';
         this.preview.logoImage.style.setProperty('opacity', '1', 'important');
         
         // Update logo icon
         this.preview.logoIcon.style.fontSize = `${finalLogoSize}px`;
         this.preview.logoIcon.style.maxWidth = `${finalLogoSize}px`;
         this.preview.logoIcon.style.maxHeight = `${finalLogoSize}px`;
       }
       
       updateBgImageScale() {
         const scale = this.inputs.bgImageScale && this.inputs.bgImageScale.value ? this.inputs.bgImageScale.value : 100;
         if (this.bgImageScaleValue) {
           this.bgImageScaleValue.textContent = `${scale}%`;
         }
         this.updateBanner();
       }
       
       updateBgImageOpacity() {
         const opacity = this.inputs.bgImageOpacity && this.inputs.bgImageOpacity.value ? this.inputs.bgImageOpacity.value : 100;
         if (this.bgImageOpacityValue) {
           this.bgImageOpacityValue.textContent = `${opacity}%`;
         }
         this.updateBanner();
       }
       
       updateBgImageXOffset() {
         if (this.inputs.bgImageXOffset && this.bgImageXOffsetValue) {
           const xOffset = this.inputs.bgImageXOffset.value;
           this.bgImageXOffsetValue.textContent = xOffset;
           this.updateBanner();
         }
       }
       
       updateBgImageYOffset() {
         if (this.inputs.bgImageYOffset && this.bgImageYOffsetValue) {
           const yOffset = this.inputs.bgImageYOffset.value;
           this.bgImageYOffsetValue.textContent = yOffset;
           this.updateBanner();
         }
       }
       
       resetBgImageOffsets() {
         // Reset X and Y offset controls to 0
         if (this.inputs.bgImageXOffset && this.bgImageXOffsetValue) {
           this.inputs.bgImageXOffset.value = 0;
           this.bgImageXOffsetValue.textContent = '0';
         }
         if (this.inputs.bgImageYOffset && this.bgImageYOffsetValue) {
           this.inputs.bgImageYOffset.value = 0;
           this.bgImageYOffsetValue.textContent = '0';
         }
         this.updateBanner();
       }
       
       moveBgImageUp() {
         if (this.inputs.bgImageYOffset) {
           const currentValue = parseInt(this.inputs.bgImageYOffset.value);
           const newValue = Math.max(-50, currentValue - 1);
           this.inputs.bgImageYOffset.value = newValue;
           this.bgImageYOffsetValue.textContent = newValue;
           this.updateBanner();
         }
       }
       
       moveBgImageDown() {
         if (this.inputs.bgImageYOffset) {
           const currentValue = parseInt(this.inputs.bgImageYOffset.value);
           const newValue = Math.min(50, currentValue + 1);
           this.inputs.bgImageYOffset.value = newValue;
           this.bgImageYOffsetValue.textContent = newValue;
           this.updateBanner();
         }
       }
       
       moveBgImageLeft() {
         if (this.inputs.bgImageXOffset) {
           const currentValue = parseInt(this.inputs.bgImageXOffset.value);
           const newValue = Math.max(-50, currentValue - 1);
           this.inputs.bgImageXOffset.value = newValue;
           this.bgImageXOffsetValue.textContent = newValue;
           this.updateBanner();
         }
       }
       
       moveBgImageRight() {
         if (this.inputs.bgImageXOffset) {
           const currentValue = parseInt(this.inputs.bgImageXOffset.value);
           const newValue = Math.min(50, currentValue + 1);
           this.inputs.bgImageXOffset.value = newValue;
           this.bgImageXOffsetValue.textContent = newValue;
           this.updateBanner();
         }
       }
       
       toggleGradientControls() {
         const isEnabled = this.inputs.gradientBgEnabled && this.inputs.gradientBgEnabled.value === 'true';
         if (this.gradientControls) {
           this.gradientControls.style.display = isEnabled ? 'block' : 'none';
         }
         if (this.gradientControls2) {
           this.gradientControls2.style.display = isEnabled ? 'block' : 'none';
         }
         if (this.gradientControls3) {
           this.gradientControls3.style.display = isEnabled ? 'block' : 'none';
         }
         if (this.gradientControls4) {
           this.gradientControls4.style.display = isEnabled ? 'block' : 'none';
         }
         this.updateBanner();
       }

      showLoadingState(loading) {
        if (loading) {
          this.preview.banner.classList.add('loading');
        } else {
          this.preview.banner.classList.remove('loading');
        }
      }
      
      applyExportStyling(tempBanner, exportDims) {
        // Get current input values
        const title = this.inputs.title.value;
        const subtitle2 = this.inputs.subtitle2.value;
        const subtitle3 = this.inputs.subtitle3.value;
        const titleSize = this.inputs.titleSize.value;
        const subtitleSize = this.inputs.subtitleSize.value;
        const font = this.inputs.fontChoice.value;
        const textAlign = this.inputs.textAlign.value;
        const titleColor = this.inputs.titleColor.value;
        const subtitleColor = this.inputs.subtitleColor.value;
        const subtitle3Color = this.inputs.subtitle3Color.value;
        const sinclairColor = this.inputs.sinclairColor.value;
        const customColor = this.inputs.customBgColor.value;
        const logoSize = this.inputs.logoSize ? this.inputs.logoSize.value : 120;
        
        console.log('Applying export styling with:', {
          title, subtitle2, subtitle3, titleSize, subtitleSize, font, textAlign,
          titleColor, subtitleColor, subtitle3Color, logoSize
        });
        
        // Set banner dimensions
        tempBanner.style.width = `${exportDims.width}px`;
        tempBanner.style.height = `${exportDims.height}px`;
        tempBanner.style.maxWidth = `${exportDims.width}px`;
        tempBanner.style.transform = 'scale(1)';
        tempBanner.style.transformOrigin = 'top left';
        
        // Get background color using the same logic as getBackgroundColor()
        const bgColor = this.getBackgroundColor();
        
        // Apply background - check if it's a gradient or solid color
        if (bgColor.includes('linear-gradient')) {
          tempBanner.style.background = bgColor;
        } else {
          tempBanner.style.backgroundColor = bgColor;
        }
        
        // Get text elements from temp banner
        const tempTitle = tempBanner.querySelector('#bannerTitle');
        const tempSubtitle2 = tempBanner.querySelector('#bannerSubtitle2');
        const tempSubtitle3 = tempBanner.querySelector('#bannerSubtitle3');
        const tempTextContainer = tempBanner.querySelector('#bannerTextContainer');
        const tempLogo = tempBanner.querySelector('#logoImage');
        
        console.log('Found elements:', {
          tempTitle: !!tempTitle,
          tempSubtitle2: !!tempSubtitle2,
          tempSubtitle3: !!tempSubtitle3,
          tempTextContainer: !!tempTextContainer,
          tempLogo: !!tempLogo
        });
        
        if (tempTitle) {
          tempTitle.innerText = title;
          tempTitle.style.setProperty('font-size', `${titleSize}px`, 'important');
          tempTitle.style.setProperty('font-family', font, 'important');
          tempTitle.style.setProperty('color', titleColor === '#ffffff' ? '#ffffff' : titleColor, 'important');
          tempTitle.style.setProperty('opacity', '1', 'important');
          tempTitle.style.setProperty('text-shadow', '0 1px 2px rgba(0, 0, 0, 0.3)', 'important');
          tempTitle.style.setProperty('font-weight', '700', 'important');
          tempTitle.style.setProperty('line-height', '1.2', 'important');
          tempTitle.style.setProperty('margin', '0', 'important');
          console.log('Applied title styling:', tempTitle.style.color);
        }
        
        if (tempSubtitle2) {
          tempSubtitle2.innerText = subtitle2;
          tempSubtitle2.style.setProperty('font-size', `${subtitleSize}px`, 'important');
          tempSubtitle2.style.setProperty('font-family', font, 'important');
          tempSubtitle2.style.setProperty('color', subtitleColor === '#ffffff' ? '#ffffff' : subtitleColor, 'important');
          tempSubtitle2.style.setProperty('opacity', '1', 'important');
          tempSubtitle2.style.setProperty('text-shadow', '0 1px 2px rgba(0, 0, 0, 0.3)', 'important');
          tempSubtitle2.style.setProperty('font-weight', '300', 'important');
          tempSubtitle2.style.setProperty('line-height', '1.2', 'important');
          tempSubtitle2.style.setProperty('margin', '0', 'important');
          console.log('Applied subtitle2 styling:', tempSubtitle2.style.color);
        }
        
        if (tempSubtitle3) {
          tempSubtitle3.innerText = subtitle3;
          tempSubtitle3.style.setProperty('font-size', `${subtitleSize}px`, 'important');
          tempSubtitle3.style.setProperty('font-family', font, 'important');
          tempSubtitle3.style.setProperty('color', subtitle3Color === '#ffffff' ? '#ffffff' : subtitle3Color, 'important');
          tempSubtitle3.style.setProperty('opacity', '1', 'important');
          tempSubtitle3.style.setProperty('text-shadow', '0 1px 2px rgba(0, 0, 0, 0.3)', 'important');
          tempSubtitle3.style.setProperty('font-weight', '300', 'important');
          tempSubtitle3.style.setProperty('line-height', '1.2', 'important');
          tempSubtitle3.style.setProperty('margin', '0', 'important');
          console.log('Applied subtitle3 styling:', tempSubtitle3.style.color);
        }
        
        if (tempTextContainer) {
          tempTextContainer.style.setProperty('text-align', textAlign, 'important');
        }
        
        if (tempLogo && tempLogo.src && tempLogo.src !== '' && tempLogo.src !== 'data:,' && tempLogo.src !== 'undefined') {
          try {
            tempLogo.style.setProperty('max-width', `${logoSize}px`, 'important');
            tempLogo.style.setProperty('max-height', `${logoSize}px`, 'important');
            tempLogo.style.setProperty('opacity', '1', 'important');
            tempLogo.style.setProperty('object-fit', 'contain', 'important');
            tempLogo.style.setProperty('z-index', '3', 'important');
            console.log('Applied logo styling:', tempLogo.style.maxWidth);
          } catch (error) {
            console.error('Error applying logo styling:', error);
            // Continue without logo styling if there's an error
          }
        }
        
        // Also ensure background image is properly handled
        const tempBgImage = tempBanner.querySelector('#bgImage');
        if (tempBgImage) {
          tempBgImage.style.setProperty('opacity', '0.85', 'important');
          tempBgImage.style.setProperty('z-index', '0', 'important');
        }
        
        console.log('Export styling complete');
      }
      
      createExportBanner(exportDims) {
        try {
          console.log('Creating export banner with dimensions:', exportDims);
          // Calculate scaled dimensions for export (same as preview scaling)
          const previewScale = this.inputs.previewScale && this.inputs.previewScale.value ? parseInt(this.inputs.previewScale.value) : 100;
        const titleSize = this.inputs.titleSize && this.inputs.titleSize.value ? parseInt(this.inputs.titleSize.value) : 48;
        const subtitleSize = this.inputs.subtitleSize && this.inputs.subtitleSize.value ? parseInt(this.inputs.subtitleSize.value) : 24;
        const logoSize = this.inputs.logoSize && this.inputs.logoSize.value ? parseInt(this.inputs.logoSize.value) : 120;
        
        const scaledTitleSize = Math.max((titleSize * previewScale) / 100, 12);
        const scaledSubtitleSize = Math.max((subtitleSize * previewScale) / 100, 10);
        const scaledLogoSize = (logoSize * previewScale) / 100;
        const basePadding = 16;
        const scaledPadding = (basePadding * previewScale) / 100;
        
        // Create a completely new banner element with all styling applied
        const banner = document.createElement('div');
        banner.id = 'exportBanner';
        const bgColor = this.getBackgroundColor();
        banner.style.cssText = `
          position: relative;
          width: ${exportDims.width}px;
          height: ${exportDims.height}px;
          max-width: ${exportDims.width}px;
          display: flex;
          align-items: center;
          justify-content: space-between;
          overflow: hidden;
          ${bgColor.includes('linear-gradient') ? `background: ${bgColor};` : `background-color: ${bgColor};`}
          padding: ${scaledPadding}px;
          border-radius: 0px;
          box-shadow: 0 8px 24px rgba(0,0,0,0.15);
          color: white;
          margin: 0 auto;
          border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create text container
        const textContainer = document.createElement('div');
        textContainer.style.cssText = `
          position: relative;
          z-index: 1;
          flex: 1;
          padding-right: ${scaledPadding}px;
          min-width: 0;
          overflow: visible;
          word-wrap: break-word;
          hyphens: auto;
          text-align: ${this.inputs.textAlign && this.inputs.textAlign.value ? this.inputs.textAlign.value : 'left'};
        `;
        
        // Create title
        const title = document.createElement('h2');
        title.id = 'exportTitle';
        title.innerText = this.inputs.title && this.inputs.title.value ? this.inputs.title.value : '';
        title.style.cssText = `
          margin: 0;
          line-height: 1.2;
          font-size: ${scaledTitleSize}px;
          font-family: ${this.inputs.fontChoice && this.inputs.fontChoice.value ? this.inputs.fontChoice.value : 'Montserrat, Arial, sans-serif'};
          font-weight: 700;
          color: ${this.inputs.titleColor && this.inputs.titleColor.value === '#ffffff' ? '#ffffff' : (this.inputs.titleColor && this.inputs.titleColor.value ? this.inputs.titleColor.value : '#ffffff')};
          opacity: 1;
          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
          word-wrap: break-word;
          overflow-wrap: break-word;
          overflow: visible;
        `;
        
        // Create subtitle2
        const subtitle2 = document.createElement('p');
        subtitle2.id = 'exportSubtitle2';
        subtitle2.innerText = this.inputs.subtitle2 && this.inputs.subtitle2.value ? this.inputs.subtitle2.value : '';
        subtitle2.style.cssText = `
          margin: 0;
          line-height: 1.2;
          font-size: ${scaledSubtitleSize}px;
          font-family: ${this.inputs.fontChoice && this.inputs.fontChoice.value ? this.inputs.fontChoice.value : 'Montserrat, Arial, sans-serif'};
          font-weight: 300;
          color: ${this.inputs.subtitleColor && this.inputs.subtitleColor.value === '#ffffff' ? '#ffffff' : (this.inputs.subtitleColor && this.inputs.subtitleColor.value ? this.inputs.subtitleColor.value : '#ffffff')};
          opacity: 1;
          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
          word-wrap: break-word;
          overflow-wrap: break-word;
          overflow: visible;
        `;
        
        // Create subtitle3
        const subtitle3 = document.createElement('p');
        subtitle3.id = 'exportSubtitle3';
        subtitle3.innerText = this.inputs.subtitle3 && this.inputs.subtitle3.value ? this.inputs.subtitle3.value : '';
        subtitle3.style.cssText = `
          margin: 0;
          line-height: 1.2;
          font-size: ${scaledSubtitleSize}px;
          font-family: ${this.inputs.fontChoice && this.inputs.fontChoice.value ? this.inputs.fontChoice.value : 'Montserrat, Arial, sans-serif'};
          font-weight: 300;
          color: ${this.inputs.subtitle3Color && this.inputs.subtitle3Color.value === '#ffffff' ? '#ffffff' : (this.inputs.subtitle3Color && this.inputs.subtitle3Color.value ? this.inputs.subtitle3Color.value : '#ffffff')};
          opacity: 1;
          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
          word-wrap: break-word;
          overflow-wrap: break-word;
          overflow: visible;
        `;
        
        // Add text elements to container
        textContainer.appendChild(title);
        textContainer.appendChild(subtitle2);
        textContainer.appendChild(subtitle3);
        
        // Add background image if it exists
        if (this.preview.bgImage.style.display !== 'none' && this.preview.bgImage.src) {
          const bgImage = document.createElement('img');
          bgImage.src = this.preview.bgImage.src;
          
          const bgImageFit = this.inputs.bgImageFit ? this.inputs.bgImageFit.value : 'cover';
          const bgImagePosition = this.inputs.bgImagePosition ? this.inputs.bgImagePosition.value : 'center';
          const bgImageXOffset = this.inputs.bgImageXOffset ? this.inputs.bgImageXOffset.value : '0';
          const bgImageYOffset = this.inputs.bgImageYOffset ? this.inputs.bgImageYOffset.value : '0';
          const bgImageScale = this.inputs.bgImageScale ? this.inputs.bgImageScale.value : '100';
          const bgImageOpacity = this.inputs.bgImageOpacity ? this.inputs.bgImageOpacity.value : '100';
          
          // Calculate position with offset (same logic as preview)
          const basePosition = bgImagePosition;
          const xOffset = parseInt(bgImageXOffset);
          const yOffset = parseInt(bgImageYOffset);
          
          // Create custom position string with offset
          let customPosition = basePosition;
          if (xOffset !== 0 || yOffset !== 0) {
            // Convert position to percentage and add offset
            let xPercent = 50; // default center
            let yPercent = 50; // default center
            
            // Parse base position
            if (basePosition.includes('left')) xPercent = 0;
            else if (basePosition.includes('right')) xPercent = 100;
            if (basePosition.includes('top')) yPercent = 0;
            else if (basePosition.includes('bottom')) yPercent = 100;
            
            // Add offset (convert -50 to 50 range to percentage)
            xPercent = Math.max(0, Math.min(100, xPercent + (xOffset + 50)));
            yPercent = Math.max(0, Math.min(100, yPercent + (yOffset + 50)));
            
            customPosition = `${xPercent}% ${yPercent}%`;
          }
          
          // For "fill" option, don't use scale transform, let object-fit handle it
          if (bgImageFit === 'fill') {
            bgImage.style.cssText = `
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              object-fit: cover;
              object-position: ${customPosition};
              transform: none;
              z-index: 0;
              opacity: ${bgImageOpacity / 100};
              overflow: hidden;
            `;
          } else {
            // Limit scale to prevent overflow - max scale based on container size
            const maxScale = Math.min(bgImageScale / 100, 2.0); // Cap at 200%
            
            bgImage.style.cssText = `
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              object-fit: ${bgImageFit};
              object-position: ${customPosition};
              transform: scale(${maxScale});
              transform-origin: center center;
              z-index: 0;
              opacity: ${bgImageOpacity / 100};
              overflow: hidden;
            `;
          }
          banner.appendChild(bgImage);
        }
        
        // Add text container to banner
        banner.appendChild(textContainer);
        
        // Add logo if present
        if (this.preview.logoImage && this.preview.logoImage.style.display !== 'none' && this.preview.logoImage.src) {
          const logo = document.createElement('img');
          logo.src = this.preview.logoImage.src;
          logo.style.cssText = `
            position: absolute;
            right: ${scaledPadding}px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 3;
            width: ${scaledLogoSize}px;
            height: auto;
            max-height: ${exportDims.height - (scaledPadding * 2)}px;
            object-fit: contain;
            z-index: 3;
          `;
          banner.appendChild(logo);
        }
        
        return banner;
        } catch (error) {
          console.error('Error creating export banner:', error);
          // Return a simple banner as fallback
          const fallbackBanner = document.createElement('div');
          fallbackBanner.style.cssText = `
            width: ${exportDims.width}px;
            height: ${exportDims.height}px;
            background-color: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000000;
            font-family: 'Montserrat', 'Arial', sans-serif;
          `;
          fallbackBanner.textContent = 'Export Error';
          return fallbackBanner;
        }
      }
      
      getBackgroundColor() {
        console.log('getBackgroundColor called');
        
        // If there's a background image, use transparent background
        if (this.preview.bgImage.style.display !== 'none' && this.preview.bgImage.src) {
          console.log('Background image detected, returning transparent');
          return 'transparent';
        }
        
        // Check if gradient is enabled
        const gradientEnabled = this.inputs.gradientBgEnabled && this.inputs.gradientBgEnabled.value === 'true';
        if (gradientEnabled) {
          const color1 = this.inputs.gradientColor1 ? this.inputs.gradientColor1.value : '#AC1A2F';
          const color2 = this.inputs.gradientColor2 ? this.inputs.gradientColor2.value : '#8b0000';
          const color3 = this.inputs.gradientColor3 ? this.inputs.gradientColor3.value : '#660000';
          const direction = this.inputs.gradientDirection ? this.inputs.gradientDirection.value : '135deg';
          console.log('Gradient enabled, returning gradient');
          return `linear-gradient(${direction}, ${color1} 0%, ${color2} 50%, ${color3} 100%)`;
        }
        
        const sinclairColor = this.inputs.sinclairColor && this.inputs.sinclairColor.value ? this.inputs.sinclairColor.value : '';
        const customColor = this.inputs.customBgColor && this.inputs.customBgColor.value ? this.inputs.customBgColor.value : '#ffffff';
        
        console.log('Sinclair color:', sinclairColor, 'Custom color:', customColor);
        
        if (sinclairColor && sinclairColor !== '' && sinclairColor !== 'transparent') {
          console.log('Processing Sinclair color:', sinclairColor);
          
          // Test if the CSS variable exists
          const testDiv = document.createElement('div');
          testDiv.style.backgroundColor = `var(${sinclairColor})`;
          document.body.appendChild(testDiv);
          const computedStyle = getComputedStyle(testDiv);
          const bgColor = computedStyle.backgroundColor;
          document.body.removeChild(testDiv);
          
          console.log('Computed Sinclair color:', bgColor);
          
          // If the color is still the variable name, it means the CSS variable wasn't found
          if (bgColor === `var(${sinclairColor})` || bgColor === 'rgba(0, 0, 0, 0)') {
            console.error('CSS variable not found:', sinclairColor);
            // Fallback to a default color
            return '#ffffff';
          }
          
          return bgColor;
        } else if (sinclairColor === 'transparent') {
          console.log('Sinclair color is transparent');
          return 'transparent';
        } else {
          console.log('Using custom color:', customColor);
          return customColor;
        }
      }
    }

    // Global functions for button onclick handlers
    let bannerCreator;

         function removeBgImage() {
       bannerCreator.removeBgImage();
     }

     function removeLogo() {
       console.log('Global removeLogo function called');
       if (bannerCreator) {
         bannerCreator.removeLogo();
       } else {
         console.error('bannerCreator not initialized');
       }
     }
     
     function removeShapeImage() {
       if (bannerCreator) {
         bannerCreator.removeShapeImage();
       } else {
         console.error('bannerCreator not initialized');
       }
     }

     function clearBackgroundColor() {
       bannerCreator.inputs.sinclairColor.value = '';
       bannerCreator.inputs.customBgColor.value = '#ffffff';
       bannerCreator.inputs.gradientBgEnabled.value = 'false';
       bannerCreator.toggleGradientControls();
       bannerCreator.updateBanner();
       bannerCreator.showMessage('✅ Background color cleared', 'success');
     }

     function downloadBanner() {
       console.log('downloadBanner function called');
       bannerCreator.downloadBanner();
     }

    function exportAsPDF() {
      console.log('exportAsPDF function called');
      bannerCreator.exportAsPDF();
    }

         function exportAsJPG() {
       console.log('exportAsJPG function called');
       bannerCreator.exportAsJPG();
     }

     function exportAsWebP() {
       console.log('exportAsWebP function called');
       bannerCreator.exportAsWebP();
     }

     function exportAsSVG() {
       console.log('exportAsSVG function called');
       bannerCreator.exportAsSVG();
     }

     function exportAsHTML() {
       console.log('exportAsHTML function called');
       bannerCreator.exportAsHTML();
     }

     function selectEmoji(emoji) {
       if (bannerCreator && bannerCreator.inputs.iconEmoji) {
         bannerCreator.inputs.iconEmoji.value = emoji;
         bannerCreator.updateBanner();
       }
     }

     function closeNewFeaturesPopup() {
       const popup = document.getElementById('newFeaturesPopup');
       if (popup) {
         popup.style.display = 'none';
       }
     }

     function showNewFeaturesPopup() {
       const popup = document.getElementById('newFeaturesPopup');
       if (popup) {
         popup.style.display = 'flex';
       }
     }

     function copyToClipboard() {
       bannerCreator.copyToClipboard();
     }
     
     function toggleSection(sectionId) {
       const section = document.getElementById(sectionId);
       const toggle = document.getElementById(sectionId.replace('Section', 'Toggle'));
       const controlSection = section.closest('.control-section');
       
       if (section.classList.contains('collapsed')) {
         section.classList.remove('collapsed');
         toggle.classList.remove('collapsed');
         toggle.textContent = '▼';
         if (controlSection) {
           controlSection.classList.remove('collapsed');
         }
       } else {
         section.classList.add('collapsed');
         toggle.classList.add('collapsed');
         toggle.textContent = '▶';
         if (controlSection) {
           controlSection.classList.add('collapsed');
         }
       }
     }
     
     function initializeCollapsibleSections() {
       const sections = [
         'templatesSection',
         'textContentSection', 
         'typographySection',
         'dimensionsSection',
         'colorsSection',
         'imagesSection',
         'exportOptionsSection'
       ];
       
       sections.forEach(sectionId => {
         const section = document.getElementById(sectionId);
         const toggle = document.getElementById(sectionId.replace('Section', 'Toggle'));
         const controlSection = section?.closest('.control-section');
         
         if (section && toggle) {
           section.classList.add('collapsed');
           toggle.classList.add('collapsed');
           toggle.textContent = '▶';
           if (controlSection) {
             controlSection.classList.add('collapsed');
           }
         }
       });
     }
     
     function setCanvasCourseCard() {
       // Store current dimensions before changing them
       const originalWidth = parseInt(bannerCreator.inputs.bannerWidth.value);
       const originalHeight = parseInt(bannerCreator.inputs.bannerHeight.value);
       
       // Change banner dimensions to Canvas LMS card size
       bannerCreator.inputs.bannerWidth.value = 262;
       bannerCreator.inputs.bannerHeight.value = 147;
       
       // Calculate scale to fit original content into card size
       const cardWidth = 262;
       const cardHeight = 147;
       
       const scaleX = cardWidth / originalWidth;
       const scaleY = cardHeight / originalHeight;
       const scale = Math.min(scaleX, scaleY);
       
       // Set preview scale to 100% by default for canvas course card
       bannerCreator.inputs.previewScale.value = 100;
       
       // Set export size to Canvas Card
       bannerCreator.inputs.exportSize.value = 'canvas-card';
       
       bannerCreator.updateBanner();
       bannerCreator.updatePreviewScale();
       
       bannerCreator.showMessage(`✅ Canvas Course Card size applied (262x147px) with 100% preview scale`, 'success');
     }
     
     function setCanvasBanner() {
       bannerCreator.inputs.bannerWidth.value = 1200;
       bannerCreator.inputs.bannerHeight.value = 200;
       // Set preview scale to 100% by default for canvas banner
       bannerCreator.inputs.previewScale.value = 100;
       bannerCreator.updateBanner();
       bannerCreator.updatePreviewScale();
       bannerCreator.showMessage('✅ Canvas Banner size applied (1200x200px) with 100% preview scale', 'success');
     }
     


    // Template functions
    function applyTemplate(templateType) {
                    const templates = {
         academic: {
           title: 'Introduction to College Writing',
           subtitle2: 'Composition & Rhetoric',
           sinclairColor: '--sinclair-red',
           fontChoice: 'Playfair Display',
           textAlign: 'left'
         },
                 business: {
           title: 'Business Management',
           subtitle2: 'Principles & Practices',
          sinclairColor: '--sinclair-charcoal',
          fontChoice: 'Montserrat',
          textAlign: 'center'
        },
                 science: {
           title: 'General Biology',
           subtitle2: 'Cell Biology & Genetics',
          sinclairColor: '--sinclair-green',
          fontChoice: 'Roboto',
          textAlign: 'left'
        },
                 arts: {
           title: 'Art Appreciation',
           subtitle2: 'Visual Arts & Design',
          sinclairColor: '--sinclair-purple',
          fontChoice: 'Quicksand',
          textAlign: 'center'
        },
                 technology: {
           title: 'Computer Programming',
           subtitle2: 'Java & Web Development',
          sinclairColor: '--sinclair-aqua',
          fontChoice: 'Fira Sans',
          textAlign: 'left'
        },
                 healthcare: {
           title: 'Nursing Fundamentals',
           subtitle2: 'Patient Care & Safety',
          sinclairColor: '--sinclair-green',
          fontChoice: 'Open Sans',
          textAlign: 'center'
        },
                 education: {
           title: 'Early Childhood Education',
           subtitle2: 'Child Development & Learning',
          sinclairColor: '--sinclair-purple',
          fontChoice: 'Merriweather',
          textAlign: 'left'
        },
                 engineering: {
           title: 'Engineering Technology',
           subtitle2: 'Mechanical & Electrical Systems',
          sinclairColor: '--sinclair-royal-blue',
          fontChoice: 'Oswald',
          textAlign: 'center'
        },
                 humanities: {
           title: 'American History',
           subtitle2: 'Colonial to Modern Era',
          sinclairColor: '--sinclair-charcoal',
          fontChoice: 'Playfair Display',
          textAlign: 'left'
        }
      };

      const template = templates[templateType];
             if (template) {
         bannerCreator.inputs.title.value = template.title;
         bannerCreator.inputs.subtitle2.value = template.subtitle2;
        bannerCreator.inputs.sinclairColor.value = template.sinclairColor;
        bannerCreator.inputs.fontChoice.value = template.fontChoice;
        bannerCreator.inputs.textAlign.value = template.textAlign;
        bannerCreator.updateBanner();
        bannerCreator.showMessage(`✅ Applied ${templateType} template!`, 'success');
      }
    }

    // Initialize the application
    window.addEventListener('DOMContentLoaded', () => {
      bannerCreator = new BannerCreator();
      initializeCollapsibleSections();
      // Initialize gradient controls state
      if (bannerCreator.toggleGradientControls) {
        bannerCreator.toggleGradientControls();
      }
      
      // Test CSS variables
      console.log('Testing CSS variables...');
      const testDiv = document.createElement('div');
      testDiv.style.backgroundColor = 'var(--sinclair-red)';
      document.body.appendChild(testDiv);
      const computedStyle = getComputedStyle(testDiv);
      console.log('Sinclair red computed as:', computedStyle.backgroundColor);
      document.body.removeChild(testDiv);
      
      // Add test function to global scope for debugging
      window.testBannerCreator = () => {
        console.log('=== Banner Creator Test ===');
        console.log('bannerCreator object:', bannerCreator);
        console.log('Sinclair color input:', bannerCreator.inputs.sinclairColor);
        console.log('Custom color input:', bannerCreator.inputs.customBgColor);
        console.log('Current Sinclair value:', bannerCreator.inputs.sinclairColor.value);
        console.log('Current custom color value:', bannerCreator.inputs.customBgColor.value);
        
        // Test getBackgroundColor function
        console.log('Testing getBackgroundColor...');
        const bgColor = bannerCreator.getBackgroundColor();
        console.log('getBackgroundColor result:', bgColor);
        
        // Test updateBanner function
        console.log('Testing updateBanner...');
        bannerCreator.updateBanner();
        console.log('updateBanner completed');
        
        // Test export function
        console.log('Testing downloadBanner...');
        bannerCreator.downloadBanner();
      };
      
      console.log('Banner Creator initialized. Run testBannerCreator() in console to test.');
      
      // Add a simple test for Sinclair colors
      window.testSinclairColors = () => {
        console.log('=== Testing Sinclair Colors ===');
        
        // Test setting a Sinclair color
        bannerCreator.inputs.sinclairColor.value = '--sinclair-red';
        console.log('Set Sinclair color to:', bannerCreator.inputs.sinclairColor.value);
        
        // Test getBackgroundColor
        const bgColor = bannerCreator.getBackgroundColor();
        console.log('Background color result:', bgColor);
        
        // Test updateBanner
        bannerCreator.updateBanner();
        console.log('updateBanner completed');
        
        // Check the actual banner background
        const banner = bannerCreator.preview.banner;
        console.log('Banner background style:', banner.style.backgroundColor);
        console.log('Banner background computed:', getComputedStyle(banner).backgroundColor);
        
        // Force a visual test
        banner.style.border = '3px solid red';
        setTimeout(() => {
          banner.style.border = '';
          console.log('Visual test completed - did you see a red border?');
        }, 2000);
      };
      
      // Add a test for custom colors
      window.testCustomColors = () => {
        console.log('=== Testing Custom Colors ===');
        
        // Test setting a custom color
        bannerCreator.inputs.customBgColor.value = '#ff0000';
        bannerCreator.inputs.sinclairColor.value = '';
        console.log('Set custom color to:', bannerCreator.inputs.customBgColor.value);
        
        // Test getBackgroundColor
        const bgColor = bannerCreator.getBackgroundColor();
        console.log('Background color result:', bgColor);
        
        // Test updateBanner
        bannerCreator.updateBanner();
        console.log('updateBanner completed');
        
        // Check the actual banner background
        const banner = bannerCreator.preview.banner;
        console.log('Banner background style:', banner.style.backgroundColor);
        console.log('Banner background computed:', getComputedStyle(banner).backgroundColor);
      };
      
      // Add a simple test for export
      window.testExport = () => {
        console.log('=== Testing Export ===');
        bannerCreator.downloadBanner();
      };
      
      // Add a test for logo removal
      window.testLogoRemoval = () => {
        console.log('=== Testing Logo Removal ===');
        
        // First, set a logo
        bannerCreator.inputs.logoChoice.value = 'sinclair-white';
        bannerCreator.handleLogoChoice();
        
        setTimeout(() => {
          console.log('Logo set, now testing removal...');
          bannerCreator.removeLogo();
          
          setTimeout(() => {
            console.log('Logo removal completed');
            console.log('Logo display:', bannerCreator.preview.logoImage.style.display);
            console.log('Logo src:', bannerCreator.preview.logoImage.src);
          }, 200);
        }, 1000);
      };
      
      // Add a test for logo switching
      window.testLogoSwitching = () => {
        console.log('=== Testing Logo Switching ===');
        
        const logos = ['sinclair-primary', 'sinclair-white', 'sinclair-compact'];
        let currentIndex = 0;
        
        const switchLogo = () => {
          const logoChoice = logos[currentIndex];
          console.log('Switching to logo:', logoChoice);
          bannerCreator.inputs.logoChoice.value = logoChoice;
          bannerCreator.handleLogoChoice();
          
          currentIndex = (currentIndex + 1) % logos.length;
          
          if (currentIndex < logos.length) {
            setTimeout(switchLogo, 2000);
          }
        };
        
        switchLogo();
      };
      
      // Add a test for logo removal and reapplication
      window.testLogoRemovalReapply = () => {
        console.log('=== Testing Logo Removal and Reapplication ===');
        
        // Set a logo
        bannerCreator.inputs.logoChoice.value = 'sinclair-primary';
        bannerCreator.handleLogoChoice();
        
        setTimeout(() => {
          console.log('Logo set, now removing...');
          bannerCreator.removeLogo();
          
          setTimeout(() => {
            console.log('Logo removed, now trying to reapply...');
            console.log('Current logo choice value:', bannerCreator.inputs.logoChoice.value);
            // Set the logo choice again and apply
            bannerCreator.inputs.logoChoice.value = 'sinclair-primary';
            bannerCreator.handleLogoChoice();
          }, 1000);
        }, 1000);
      };
      
      // Add a simple test for export with logo
      window.testExportWithLogo = () => {
        console.log('=== Testing Export with Logo ===');
        
        // Set a logo
        bannerCreator.inputs.logoChoice.value = 'sinclair-primary';
        bannerCreator.handleLogoChoice();
        
        setTimeout(() => {
          console.log('Logo set, now testing export...');
          bannerCreator.downloadBanner();
        }, 1000);
      };
      
      // Add a test that exports without logo to verify the issue
      window.testExportWithoutLogo = () => {
        console.log('=== Testing Export without Logo ===');
        
        // Remove any existing logo
        bannerCreator.removeLogo();
        
        setTimeout(() => {
          console.log('Logo removed, now testing export...');
          bannerCreator.downloadBanner();
        }, 1000);
      };
      
      // Add a test that temporarily hides logo for export
      window.testExportWithHiddenLogo = () => {
        console.log('=== Testing Export with Hidden Logo ===');
        
        // Set a logo
        bannerCreator.inputs.logoChoice.value = 'sinclair-primary';
        bannerCreator.handleLogoChoice();
        
        setTimeout(() => {
          console.log('Logo set, now hiding logo and testing export...');
          
          // Temporarily hide logo
          const originalDisplay = bannerCreator.preview.logoImage.style.display;
          bannerCreator.preview.logoImage.style.display = 'none';
          
          bannerCreator.downloadBanner();
          
          // Restore logo after export
          setTimeout(() => {
            bannerCreator.preview.logoImage.style.display = originalDisplay;
          }, 2000);
        }, 1000);
      };
      
      // Add a test for export with logo (logo included in export with html2canvas)
      window.testExportWithLogo = () => {
        console.log('=== Testing Export with Logo (Logo included in export with html2canvas) ===');
        
        // Set a logo
        bannerCreator.inputs.logoChoice.value = 'sinclair-primary';
        bannerCreator.handleLogoChoice();
        
        setTimeout(() => {
          console.log('Logo set, now testing export (logo should be included in export)...');
          bannerCreator.downloadBanner();
        }, 1000);
      };
      
      // Add a test to check logo file availability
      window.testLogoFiles = () => {
        console.log('=== Testing Logo File Availability ===');
        
        const logoUrls = {
          'sinclair-primary': './logos/sinclair-primary.png',
          'sinclair-white': './logos/sinclair-white.png',
          'sinclair-compact': './logos/sinclair-compact.png'
        };
        
        Object.entries(logoUrls).forEach(([name, url]) => {
          const img = new Image();
          img.onload = () => {
            console.log(`✅ ${name}: File exists and loads successfully`);
          };
          img.onerror = () => {
            console.log(`❌ ${name}: File not found or cannot be loaded`);
          };
          img.src = url;
        });
      };
      
      // Add a test to debug export issues
      window.debugExport = () => {
        console.log('=== Debugging Export Issues ===');
        
        console.log('Current logo state:', {
          exists: !!bannerCreator.preview.logoImage,
          display: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.style.display : 'N/A',
          src: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.src : 'N/A',
          complete: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.complete : 'N/A'
        });
        
        console.log('html2canvas available:', typeof html2canvas !== 'undefined');
        console.log('jspdf available:', typeof jspdf !== 'undefined');
      };
      
      // Add a test to verify logo is being added to export
      window.testLogoInExport = () => {
        console.log('=== Testing Logo in Export ===');
        
        // Set a logo
        bannerCreator.inputs.logoChoice.value = 'sinclair-primary';
        bannerCreator.handleLogoChoice();
        
        setTimeout(() => {
          console.log('Logo set, now testing export banner creation...');
          
          // Test the createExportBanner function directly
          const exportDims = bannerCreator.getExportDimensions();
          const tempBanner = bannerCreator.createExportBanner(exportDims);
          
          // Check if logo element is in the banner
          const logoElements = tempBanner.querySelectorAll('img');
          console.log('Logo elements found in export banner:', logoElements.length);
          
          logoElements.forEach((img, index) => {
            console.log(`Logo ${index + 1}:`, {
              src: img.src,
              style: img.style.cssText,
              width: img.width,
              height: img.height
            });
          });
          
          // Clean up
          if (tempBanner.parentNode) {
            tempBanner.parentNode.removeChild(tempBanner);
          }
        }, 1000);
      };
      
      // Add a test to check export settings and logo state
      window.testExportSettings = () => {
        console.log('=== Testing Export Settings and Logo State ===');
        
        console.log('Export Settings:', {
          exportSize: bannerCreator.inputs.exportSize ? bannerCreator.inputs.exportSize.value : 'N/A',
          exportQuality: bannerCreator.inputs.exportQuality ? bannerCreator.inputs.exportQuality.value : 'N/A',
          exportFileName: bannerCreator.inputs.exportFileName ? bannerCreator.inputs.exportFileName.value : 'N/A'
        });
        
        console.log('Logo Settings:', {
          logoChoice: bannerCreator.inputs.logoChoice ? bannerCreator.inputs.logoChoice.value : 'N/A',
          logoSize: bannerCreator.inputs.logoSize ? bannerCreator.inputs.logoSize.value : 'N/A',
          logoUpload: bannerCreator.inputs.logoUpload ? bannerCreator.inputs.logoUpload.value : 'N/A'
        });
        
        console.log('Current Logo State:', {
          exists: !!bannerCreator.preview.logoImage,
          display: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.style.display : 'N/A',
          src: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.src : 'N/A',
          complete: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.complete : 'N/A',
          naturalWidth: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.naturalWidth : 'N/A',
          naturalHeight: bannerCreator.preview.logoImage ? bannerCreator.preview.logoImage.naturalHeight : 'N/A'
        });
        
        // Test logo file accessibility
        if (bannerCreator.preview.logoImage && bannerCreator.preview.logoImage.src) {
          const testImg = new Image();
          testImg.onload = () => {
            console.log('✅ Logo file is accessible and loads successfully');
          };
          testImg.onerror = () => {
            console.log('❌ Logo file is not accessible');
          };
          testImg.src = bannerCreator.preview.logoImage.src;
        }
      };
    });
  </script>
</body>
</html> 
